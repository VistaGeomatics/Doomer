<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Warehouse Run – Stolen Property Hunt</title>

  <!-- Mobile: prevent zoom + fit viewport nicely -->
  <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />

  <style>
    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      touch-action: none; /* stop scroll/pinch conflicts */
    }

    /* Fullscreen stage */
    #stage {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               calc(env(safe-area-inset-bottom) + 120px)
               env(safe-area-inset-left);
    }

    canvas {
      display: block;
      background: #000;
      border: 2px solid #444;
      /* responsive: maximize canvas area while keeping 16:9 */
      width: min(100vw, calc((100vh - 120px) * (16 / 9)));
      height: min(calc(100vh - 120px), calc(100vw * (9 / 16)));
      image-rendering: pixelated;
      touch-action: none;
    }

    /* HUD overlay (small, non-intrusive on mobile) */
    #hud {
      position: fixed;
      left: 0; right: 0;
      top: 0;
      padding: calc(env(safe-area-inset-top) + 10px) 12px 10px;
      text-align: center;
      font-size: 13px;
      color: #bbb;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(0,0,0,0.55), rgba(0,0,0,0));
    }

    #title {
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(255,255,255,0.35);
    }

    #status { margin-top: 6px; color: rgba(255,255,255,0.7); }

    #controlsHint {
      margin-top: 6px;
      font-size: 12px;
      color: rgba(255,255,255,0.35);
    }

    /* Touch controls (joystick + punch) */
    #touch-controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 120px;
      display: none; /* enabled by JS on touch devices */
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px calc(14px + env(safe-area-inset-bottom));
      z-index: 50;
      pointer-events: none; /* children re-enable */
      background: linear-gradient(to top, rgba(0,0,0,0.45), rgba(0,0,0,0));
    }

    /* More transparent controls */
    .control-block { pointer-events: auto; user-select: none; -webkit-user-select: none; }

    /* Joystick */
    #joy-base {
      width: 118px;
      height: 118px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 2px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 18px rgba(0,0,0,0.45);
      position: relative;
      touch-action: none;
      overflow: hidden;
    }

    #joy-ring {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: radial-gradient(circle at center, rgba(255,255,255,0.06), rgba(255,255,255,0.00) 60%);
      opacity: 0.9;
    }

    #joy-stick {
      width: 54px;
      height: 54px;
      border-radius: 999px;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.12);
      border: 2px solid rgba(255,255,255,0.14);
      box-shadow: 0 10px 16px rgba(0,0,0,0.35);
      touch-action: none;
      will-change: transform;
    }

    /* Punch button */
    #punch {
      width: 110px;
      height: 110px;
      border-radius: 28px;
      border: 2px solid rgba(255,255,255,0.16);
      background: rgba(170, 30, 30, 0.45);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      letter-spacing: 0.04em;
      font-size: 16px;
      display: grid;
      place-items: center;
      box-shadow: 0 12px 22px rgba(0,0,0,0.55);
      touch-action: none;
    }

    #punch:active, #punch.active {
      transform: translateY(1px);
      background: rgba(200, 40, 40, 0.60);
      border-color: rgba(255,255,255,0.26);
    }

    /* Slightly tighter top HUD on small screens */
    @media (max-width: 820px) {
      #controlsHint { display: none; }
      canvas { border-width: 0; }
    }
  </style>
</head>

<body>
  <div id="hud">
    <div id="title">WAREHOUSE RUN – STOLEN GPS</div>
    <div id="status">Loading…</div>
    <div id="controlsHint">W/S Move, A/D or ←/→ Turn, Space Punch, Q Floor Quality</div>
  </div>

  <div id="stage">
    <canvas id="game"></canvas>
  </div>

  <div id="touch-controls" aria-label="Mobile controls">
    <div class="control-block">
      <div id="joy-base" aria-label="Joystick">
        <div id="joy-ring"></div>
        <div id="joy-stick"></div>
      </div>
    </div>

    <div class="control-block">
      <div id="punch" aria-label="Punch button">PUNCH</div>
    </div>
  </div>

  <!-- background music -->
  <audio id="bgm" src="the-metal-loop-full.wav" loop></audio>

  <script>
    /**********************
     * MOBILE ANTI-ZOOM FIXES
     **********************/
    // iOS Safari gesture zoom
    document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive:false });
    // Double-tap zoom prevention (older iOS)
    let _lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - _lastTouchEnd <= 280) e.preventDefault();
      _lastTouchEnd = now;
    }, { passive:false });

    /**********************
     * CANVAS SETUP (internal resolution + responsive sizing)
     **********************/
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const bgm = document.getElementById("bgm");

    // Keep 16:9 internal resolution, scale via CSS for mobile fullscreen
    const BASE_W = 960;
    const BASE_H = 540;
    canvas.width = BASE_W;
    canvas.height = BASE_H;

    function loadImage(path) {
      const img = new Image();
      img.src = path;
      return img;
    }
    function isImgReady(img) { return img && img.complete && img.naturalWidth > 0; }

    function drawFullScreenImage(img) {
      const w = canvas.width, h = canvas.height;
      if (!isImgReady(img)) { ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h); return; }
      ctx.drawImage(img, 0, 0, w, h);
    }

    /**********************
     * GAME STATE
     **********************/
    let gameState = "title"; // title, prescreen, running, continuePrompt, levelCompleteDelay, levelComplete, gameOver
    let continueUsed = false;

    const LEVEL_TIME = 120;
    let remainingTime = LEVEL_TIME;

    let levelCompleteDelay = 0; // 2s delay before final cutscene

    const screenImages = {
      title: loadImage("Level3.png"),
      prescreen: loadImage("Prescreen.png"),
      complete: loadImage("level complete.png"),
      gameover: loadImage("Fail.png"),
      continue: loadImage("Continue.png")
    };

    /**********************
     * MUSIC / SFX
     **********************/
    let bgmStarted = false;
    function startBgm() {
      if (bgmStarted || !bgm) return;
      bgm.volume = 0.3;
      bgm.play().catch(() => {});
      bgmStarted = true;
    }
    const punchSound = new Audio("Punch.wav");
    punchSound.volume = 1.0;

    /**********************
     * FEEDBACK (hit marker / shake / vignette)
     **********************/
    let hitMarkerT = 0;
    let shakeT = 0;
    let shakeMag = 0;
    let hitVignetteT = 0;

    /**********************
     * MOVEMENT (SLOWED + SMOOTHER)
     **********************/
    let moveVel = 0;
    let turnVel = 0;

    // Slower, less twitchy
    const MOVE_ACCEL = 520;
    const MOVE_FRICTION = 1500;
    const MOVE_MAX = 115;

    const TURN_ACCEL = 6.2;
    const TURN_FRICTION = 18.0;
    const TURN_MAX = 1.6;

    /**********************
     * MAP
     **********************/
    const asciiMap = [
      "################################",
      "#...............##............#",
      "#....#####......##....#####...#",
      "#..###....####....####....###.#",
      "#..######.....................#",
      "#..######....######...........#",
      "#..######....######....#####..#",
      "#..###....####....####....###.#",
      "#.....####.....####.....####..#",
      "#..###....####....####....###.#",
      "#..###........P.........###...#",
      "#..###....####....####....###.#",
      "#.....####.....####.....####..#",
      "#..###....####....####....###.#",
      "#..######.....................#",
      "#..######....######...........#",
      "#..######....######....#####..#",
      "#..###....####....####....###.#",
      "#...............##............#",
      "#...............##............#",
      "################################"
    ];

    const MAP_HEIGHT = asciiMap.length;
    const MAP_WIDTH  = asciiMap[0].length;

    const map = asciiMap.map(row => row.split("").map(ch => (ch === "." || ch === "P") ? 0 : 1));
    const TILE_SIZE = 64;

    function tileAt(tx, ty) {
      if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) return 1;
      return map[ty][tx];
    }
    function isSolid(px, py) {
      const tx = Math.floor(px / TILE_SIZE);
      const ty = Math.floor(py / TILE_SIZE);
      return tileAt(tx, ty) !== 0;
    }

    /**********************
     * PLAYER
     **********************/
    let spawnX = 1.5, spawnY = 1.5;
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (asciiMap[y][x] === "P") { spawnX = x + 0.5; spawnY = y + 0.5; }
      }
    }
    const player = { x: spawnX * TILE_SIZE, y: spawnY * TILE_SIZE, angle: 0 };

    const FOV = Math.PI / 3;
    const NUM_RAYS = canvas.width;
    const MAX_DEPTH = 18 * TILE_SIZE;
    const depthBuffer = new Array(NUM_RAYS);

    /**********************
     * INPUT (Keyboard)
     **********************/
    const keys = {};

    // Floor quality toggle (1 sharp, 2 default, 3 faster)
    let FLOOR_RES = 2;

    window.addEventListener("keydown", (e) => {
      startBgm();
      if (!keys[e.code] && e.code === "Space") handlePrimaryAction();

      if (e.code === "KeyQ") {
        FLOOR_RES = (FLOOR_RES === 1) ? 2 : (FLOOR_RES === 2) ? 3 : 1;
        rebuildFloorBuffer();
      }

      keys[e.code] = true;
    }, { passive:true });

    window.addEventListener("keyup", (e) => { keys[e.code] = false; }, { passive:true });

    /**********************
     * TOUCH CONTROLS (Joystick + Punch)
     **********************/
    const touchControlsEl = document.getElementById("touch-controls");
    const isTouch = window.matchMedia("(pointer:coarse)").matches || navigator.maxTouchPoints > 0;
    if (isTouch) touchControlsEl.style.display = "flex";

    const joyBase = document.getElementById("joy-base");
    const joyStick = document.getElementById("joy-stick");
    const punchBtn = document.getElementById("punch");

    // Joystick output in range [-1..1]
    const joy = { x: 0, y: 0, active: false, id: null, cx: 0, cy: 0, radius: 0 };

    // Make joystick calm + usable
    const JOY_DEADZONE = 0.30;     // bigger deadzone = less twitchy
    const JOY_TURN_SCALE = 0.38;   // calmer turning
    const JOY_MOVE_SCALE = 0.72;   // calmer movement
    const JOY_CURVE_EXP = 2.2;     // soft near center
    const JOY_SMOOTH = 14;         // input smoothing

    const joyFiltered = { x: 0, y: 0 };

    function setJoyVisual(nx, ny) {
      // nx/ny are -1..1 in joy space
      const r = joy.radius;
      const px = nx * r;
      const py = ny * r;
      joyStick.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`;
    }
    function resetJoy() {
      joy.x = 0; joy.y = 0; joy.active = false; joy.id = null;
      setJoyVisual(0, 0);
    }
    function curve(v) {
      const s = Math.sign(v);
      return s * Math.pow(Math.abs(v), JOY_CURVE_EXP);
    }

    function onJoyDown(ev) {
      startBgm();
      ev.preventDefault();
      ev.stopPropagation();

      const rect = joyBase.getBoundingClientRect();
      joy.cx = rect.left + rect.width / 2;
      joy.cy = rect.top + rect.height / 2;

      // More travel = less sensitive
      joy.radius = Math.min(rect.width, rect.height) * 0.32; // ~38px on 118px base
      joy.active = true;
      joy.id = ev.pointerId;

      joyBase.setPointerCapture(ev.pointerId);
      onJoyMove(ev);
    }

    function onJoyMove(ev) {
      if (!joy.active || ev.pointerId !== joy.id) return;
      ev.preventDefault();
      ev.stopPropagation();

      const dx = ev.clientX - joy.cx;
      const dy = ev.clientY - joy.cy;

      const dist = Math.hypot(dx, dy) || 1;
      const max = joy.radius;

      // Clamp within radius
      const clamped = Math.min(dist, max);
      const nx = (dx / dist) * (clamped / max);
      const ny = (dy / dist) * (clamped / max);

      // Deadzone
      const mag = Math.hypot(nx, ny);
      if (mag < JOY_DEADZONE) {
        joy.x = 0; joy.y = 0;
        setJoyVisual(0, 0);
        return;
      }

      // Re-normalize after deadzone so it ramps nicely
      const t = (mag - JOY_DEADZONE) / (1 - JOY_DEADZONE);
      const ux = (nx / mag) * t;
      const uy = (ny / mag) * t;

      // Curve for smoothness near center
      joy.x = curve(ux);
      joy.y = curve(uy);

      setJoyVisual(ux, uy);
    }

    function onJoyUp(ev) {
      if (ev.pointerId !== joy.id) return;
      ev.preventDefault();
      ev.stopPropagation();
      resetJoy();
    }

    joyBase.addEventListener("pointerdown", onJoyDown, { passive:false });
    joyBase.addEventListener("pointermove", onJoyMove, { passive:false });
    joyBase.addEventListener("pointerup", onJoyUp, { passive:false });
    joyBase.addEventListener("pointercancel", onJoyUp, { passive:false });

    // Punch press once (and DO NOT let it bubble to canvas → avoids weird zoom/selection)
    (function bindPunchOnce(){
      let pressed = false;

      punchBtn.addEventListener("pointerdown", (ev) => {
        startBgm();
        ev.preventDefault();
        ev.stopPropagation();

        if (pressed) return;
        pressed = true;
        punchBtn.classList.add("active");

        if (gameState === "running") {
          if (!punchState.active) startPunch();
        } else {
          handlePrimaryAction();
        }
      }, { passive:false });

      const release = (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        pressed = false;
        punchBtn.classList.remove("active");
      };

      punchBtn.addEventListener("pointerup", release, { passive:false });
      punchBtn.addEventListener("pointercancel", release, { passive:false });
      punchBtn.addEventListener("pointerleave", release, { passive:false });
    })();

    // Tap canvas to advance screens (NOT used for look-drag anymore, avoids twitchy turning)
    canvas.addEventListener("pointerdown", (e) => {
      startBgm();
      e.preventDefault();
      handlePrimaryAction();
    }, { passive:false });

    /**********************
     * PRIMARY ACTION
     **********************/
    function handlePrimaryAction() {
      if (gameState === "running" && !punchState.active) { startPunch(); return; }
      if (gameState === "title") { gameState = "prescreen"; return; }
      if (gameState === "prescreen") { startLevel(); return; }
      if (gameState === "continuePrompt") {
        if (!continueUsed) { continueUsed = true; startLevel(); }
        return;
      }
      if (gameState === "levelComplete" || gameState === "gameOver") resetGameCompletely();
    }

    /**********************
     * ENEMIES / ITEMS
     **********************/
    const enemyStartPositions = [
      { x: (6.5)  * TILE_SIZE, y: (3.5)  * TILE_SIZE },
      { x: (22.5) * TILE_SIZE, y: (3.5)  * TILE_SIZE },
      { x: (6.5)  * TILE_SIZE, y: (13.5) * TILE_SIZE },
      { x: (22.5) * TILE_SIZE, y: (13.5) * TILE_SIZE },
      { x: (15.5) * TILE_SIZE, y: (9.5)  * TILE_SIZE }
    ];

    const enemies = enemyStartPositions.map(p => ({
      x: p.x, y: p.y,
      alive: true,
      health: 3,
      state: "alive",
      deathTimer: 0,
      finalHitTimer: 0,
      dir: Math.random() * Math.PI * 2,
      turnTimer: 1 + Math.random() * 2,
      animTime: 0,
      animFrame: 0,
      moving: false,
      movingAway: false,
      prevDistToPlayer: 0,
      hitTimer: 0
    }));

    const ENEMY_SPEED = 48; // slightly slower
    const ENEMY_AVOID_RADIUS = 4 * TILE_SIZE;
    const ENEMY_ANIM_FRAME_TIME = 0.16;

    let itemsCollected = 0;
    const totalItems = enemies.length;

    function updateStatusText() {
      statusEl.textContent = (itemsCollected >= totalItems)
        ? "All GPS components recovered!"
        : `GPS components recovered: ${itemsCollected} / ${totalItems}`;
    }

    function resetEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i], p = enemyStartPositions[i];
        e.x = p.x; e.y = p.y;
        e.alive = true; e.health = 3; e.state = "alive";
        e.deathTimer = 0; e.finalHitTimer = 0;
        e.dir = Math.random() * Math.PI * 2;
        e.turnTimer = 1 + Math.random() * 2;
        e.animTime = 0; e.animFrame = 0;
        e.moving = false; e.movingAway = false;
        e.prevDistToPlayer = 0; e.hitTimer = 0;
      }
    }

    function startLevel() {
      gameState = "running";
      remainingTime = LEVEL_TIME;
      levelCompleteDelay = 0;

      player.x = spawnX * TILE_SIZE;
      player.y = spawnY * TILE_SIZE;
      player.angle = 0;

      moveVel = 0;
      turnVel = 0;
      joyFiltered.x = 0;
      joyFiltered.y = 0;
      resetJoy();

      resetEnemies();
      itemsCollected = 0;
      updateStatusText();
    }

    function resetGameCompletely() {
      continueUsed = false;
      itemsCollected = 0;
      remainingTime = LEVEL_TIME;
      levelCompleteDelay = 0;

      resetEnemies();
      player.x = spawnX * TILE_SIZE;
      player.y = spawnY * TILE_SIZE;
      player.angle = 0;

      moveVel = 0;
      turnVel = 0;
      joyFiltered.x = 0;
      joyFiltered.y = 0;
      resetJoy();

      gameState = "title";
      updateStatusText();
    }

    function updateEnemies(dt) {
      for (const e of enemies) {
        if (e.state === "finalHit") {
          e.finalHitTimer -= dt;
          if (e.finalHitTimer <= 0) { e.state = "dying"; e.deathTimer = 0.6; }
          continue;
        }
        if (e.state === "dying") {
          e.deathTimer -= dt;
          if (e.deathTimer <= 0) e.state = "dead";
          continue;
        }
        if (e.state === "dead") continue;

        if (e.hitTimer > 0) {
          e.hitTimer -= dt;
          if (e.hitTimer < 0) e.hitTimer = 0;
        }

        const dx0 = player.x - e.x;
        const dy0 = player.y - e.y;
        const d0 = Math.hypot(dx0, dy0);
        e.prevDistToPlayer = d0;

        if (d0 < ENEMY_AVOID_RADIUS) {
          const a = Math.atan2(dy0, dx0);
          e.dir = a + Math.PI + (Math.random() - 0.5) * 0.4;
          e.turnTimer = 0.3;
        } else {
          e.turnTimer -= dt;
          if (e.turnTimer <= 0) {
            e.dir = Math.random() * Math.PI * 2;
            e.turnTimer = 1 + Math.random() * 2;
          }
        }

        const dx = Math.cos(e.dir) * ENEMY_SPEED * dt;
        const dy = Math.sin(e.dir) * ENEMY_SPEED * dt;

        const oldX = e.x, oldY = e.y;
        const nx = e.x + dx;
        const ny = e.y + dy;

        if (!isSolid(nx, e.y)) e.x = nx; else e.dir = Math.random() * Math.PI * 2;
        if (!isSolid(e.x, ny)) e.y = ny; else e.dir = Math.random() * Math.PI * 2;

        e.moving = Math.hypot(e.x - oldX, e.y - oldY) > 0.5;

        const dx1 = player.x - e.x;
        const dy1 = player.y - e.y;
        const d1 = Math.hypot(dx1, dy1);
        e.movingAway = d1 > e.prevDistToPlayer + 1;

        if (e.moving) {
          e.animTime += dt;
          if (e.animTime >= ENEMY_ANIM_FRAME_TIME) {
            e.animTime = 0;
            e.animFrame = 1 - e.animFrame;
          }
        } else {
          e.animTime = 0;
          e.animFrame = 0;
        }
      }
    }

    /**********************
     * PUNCH
     **********************/
    const punchState = { active:false, time:0, duration:0.25, justHit:false };
    const PUNCH_RANGE = 1.5 * TILE_SIZE;
    const PUNCH_ARC   = Math.PI / 4;

    function normalizeAngle(a) {
      while (a < -Math.PI) a += 2*Math.PI;
      while (a >  Math.PI) a -= 2*Math.PI;
      return a;
    }

    function startPunch() {
      punchState.active = true;
      punchState.time = 0;
      punchState.justHit = false;

      if (navigator.vibrate) navigator.vibrate(20);

      try { punchSound.currentTime = 0; punchSound.play().catch(() => {}); } catch {}
      performPunch();
    }

    function performPunch() {
      let hitAny = false;

      for (const enemy of enemies) {
        if (enemy.state !== "alive") continue;

        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist > PUNCH_RANGE) continue;

        const angleTo = Math.atan2(dy, dx);
        const diff = normalizeAngle(angleTo - player.angle);
        if (Math.abs(diff) > PUNCH_ARC) continue;

        enemy.health -= 1;

        if (enemy.health > 0) {
          enemy.hitTimer = 0.2;
        } else {
          enemy.alive = false;
          enemy.state = "finalHit";
          enemy.finalHitTimer = 0.2;
          enemy.hitTimer = 0;
          itemsCollected++;
        }

        hitAny = true;
      }

      punchState.justHit = hitAny;

      if (hitAny) {
        hitMarkerT = 0.15;
        shakeT = 0.10;
        shakeMag = 5;
        hitVignetteT = 0.18;
        updateStatusText();
      }
    }

    const punchImages = [];
    let punchImagesLoaded = 0;
    ["punch1.png", "punch2.png", "punch3.png"].forEach((file, idx) => {
      const img = new Image();
      img.src = file;
      img.onload = () => { punchImagesLoaded++; };
      punchImages[idx] = img;
    });

    function getPunchFrame() {
      if (!punchState.active || punchImagesLoaded === 0) return null;
      const t = punchState.time / punchState.duration;
      let frameIndex = 0;
      if (t > 0.4 && t <= 0.8) frameIndex = 1;
      else if (t > 0.8) frameIndex = 2;
      return punchImages[frameIndex];
    }

    /**********************
     * TEXTURES
     **********************/
    const wallTextureFiles = ["Wall1.png", "Wall2.png", "wall3.png"];
    const wallTextures = wallTextureFiles.map(f => { const img = new Image(); img.src = f; return img; });

    const floorImg = new Image();
    floorImg.src = "floor 69.jpg";

    const floorTex = { ready:false, w:0, h:0, data:null };

    floorImg.onload = () => {
      const c = document.createElement("canvas");
      c.width = floorImg.width;
      c.height = floorImg.height;
      const cctx = c.getContext("2d", { willReadFrequently: true });
      cctx.drawImage(floorImg, 0, 0);
      const imgd = cctx.getImageData(0, 0, c.width, c.height);
      floorTex.ready = true;
      floorTex.w = c.width;
      floorTex.h = c.height;
      floorTex.data = imgd.data;
    };

    const floorBuf = document.createElement("canvas");
    const floorCtx = floorBuf.getContext("2d", { willReadFrequently: true });
    let floorFrame = null;

    function rebuildFloorBuffer() {
      floorBuf.width = Math.ceil(canvas.width / FLOOR_RES);
      floorBuf.height = Math.ceil((canvas.height / 2) / FLOOR_RES);
      floorFrame = floorCtx.createImageData(floorBuf.width, floorBuf.height);
    }
    rebuildFloorBuffer();

    const FLOOR_TEX_WORLD_SCALE = 0.22;

    function sampleFloorRGB(wx, wy) {
      const tw = floorTex.w, th = floorTex.h;
      let tx = Math.floor(wx * FLOOR_TEX_WORLD_SCALE) % tw;
      let ty = Math.floor(wy * FLOOR_TEX_WORLD_SCALE) % th;
      if (tx < 0) tx += tw;
      if (ty < 0) ty += th;
      const idx = (ty * tw + tx) * 4;
      return [ floorTex.data[idx], floorTex.data[idx+1], floorTex.data[idx+2] ];
    }

    function renderFloorPerspective(halfH) {
      const w = canvas.width, h = canvas.height;
      if (!floorTex.ready || !floorFrame) {
        ctx.fillStyle = "#303033";
        ctx.fillRect(0, halfH, w, halfH);
        return;
      }

      const bw = floorBuf.width, bh = floorBuf.height;
      const data = floorFrame.data;

      const leftA  = player.angle - FOV / 2;
      const rightA = player.angle + FOV / 2;

      const leftDX  = Math.cos(leftA);
      const leftDY  = Math.sin(leftA);
      const rightDX = Math.cos(rightA);
      const rightDY = Math.sin(rightA);

      const cameraHeight = 0.55 * TILE_SIZE;
      const projPlane = halfH;

      for (let yb = 0; yb < bh; yb++) {
        const screenY = halfH + (yb * FLOOR_RES);
        const p = (screenY - halfH);
        const rowDist = (cameraHeight * projPlane) / Math.max(1, p);

        const stepX = rowDist * (rightDX - leftDX) / bw;
        const stepY = rowDist * (rightDY - leftDY) / bw;

        let fx = player.x + rowDist * leftDX;
        let fy = player.y + rowDist * leftDY;

        const shade = Math.max(0.15, 1 - (rowDist / (MAX_DEPTH * 0.9)));

        for (let xb = 0; xb < bw; xb++) {
          const [r0,g0,b0] = sampleFloorRGB(fx, fy);
          const o = (yb * bw + xb) * 4;
          data[o]   = Math.floor(r0 * shade);
          data[o+1] = Math.floor(g0 * shade);
          data[o+2] = Math.floor(b0 * shade);
          data[o+3] = 255;
          fx += stepX; fy += stepY;
        }
      }

      floorCtx.putImageData(floorFrame, 0, 0);
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(floorBuf, 0, 0, bw, bh, 0, halfH, w, h - halfH);
      ctx.restore();
    }

    /**********************
     * SPRITES
     **********************/
    const burglarSprites = { standing:null, walk1:null, walk2:null, away:null, hit:null, falling:null, dead:null };
    function loadBurglarSprite(name, file) {
      const img = new Image();
      img.src = file;
      img.onload = () => { burglarSprites[name] = img; };
      return img;
    }

    loadBurglarSprite("standing","BGStanding.png");
    loadBurglarSprite("walk1","BGWalking1.png");
    loadBurglarSprite("walk2","BGwalking2.png");
    loadBurglarSprite("away","BGWalkingaway.png");
    loadBurglarSprite("hit","BGpunch.png");
    loadBurglarSprite("falling","Falling1.png");
    loadBurglarSprite("dead","Dead.png");

    /**********************
     * HUD ASSETS
     **********************/
    const hud = { bar:null, items:[], happyFace:null, angryFace:null };
    hud.bar = loadImage("Bar.png");
    hud.items[0] = loadImage("BRX72.png");
    hud.items[1] = loadImage("Data collector copy.png");
    hud.items[2] = loadImage("Tribrachs.png");
    hud.items[3] = loadImage("battery copy.png");
    hud.items[4] = loadImage("BRX71.png");
    hud.happyFace = loadImage("Happy Face.png");
    hud.angryFace = loadImage("Angry face.png");

    function areAssetsReady() {
      for (const k in screenImages) if (!isImgReady(screenImages[k])) return false;
      if (!isImgReady(hud.bar)) return false;
      for (const it of hud.items) if (!isImgReady(it)) return false;
      if (!isImgReady(hud.happyFace) || !isImgReady(hud.angryFace)) return false;
      if (!isImgReady(burglarSprites.standing)) return false;
      if (!floorTex.ready) return false;
      return true;
    }

    /**********************
     * RAYCAST
     **********************/
    function castRay(rayAngle) {
      rayAngle = (rayAngle + Math.PI*2) % (Math.PI*2);
      const cos = Math.cos(rayAngle), sin = Math.sin(rayAngle);

      const stepSize = 4;
      let rayX = player.x, rayY = player.y, distance = 0;
      let hitTile = 0, hitMapX = 0, hitMapY = 0;

      while (distance < MAX_DEPTH) {
        rayX += cos * stepSize;
        rayY += sin * stepSize;
        distance += stepSize;

        const tx = Math.floor(rayX / TILE_SIZE);
        const ty = Math.floor(rayY / TILE_SIZE);

        if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) {
          hitTile = 1; hitMapX = tx; hitMapY = ty; break;
        }

        const t = tileAt(tx, ty);
        if (t !== 0) { hitTile = t; hitMapX = tx; hitMapY = ty; break; }
      }

      return { distance, tile: hitTile, hitMapX, hitMapY, worldX: rayX, worldY: rayY };
    }

    /**********************
     * ENEMY RENDER
     **********************/
    function chooseBurglarFrame(enemy) {
      if (enemy.state === "finalHit" && burglarSprites.hit) return burglarSprites.hit;
      if (enemy.state === "dying" && burglarSprites.falling) return burglarSprites.falling;
      if (enemy.state === "dead" && burglarSprites.dead) return burglarSprites.dead;
      if (enemy.hitTimer > 0 && burglarSprites.hit) return burglarSprites.hit;
      if (!burglarSprites.standing) return null;

      if (!enemy.moving) return burglarSprites.standing;
      if (enemy.movingAway && burglarSprites.away) return burglarSprites.away;
      if (enemy.animFrame === 0 && burglarSprites.walk1) return burglarSprites.walk1;
      if (enemy.animFrame === 1 && burglarSprites.walk2) return burglarSprites.walk2;

      return burglarSprites.standing;
    }

    function getVisibleEnemies() {
      const result = [];
      for (const enemy of enemies) {
        const dx = enemy.x - player.x, dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        const angleTo = Math.atan2(dy, dx);
        const diff = normalizeAngle(angleTo - player.angle);
        if (Math.abs(diff) > FOV/2) continue;
        result.push({ enemy, dist, diff });
      }
      result.sort((a,b) => b.dist - a.dist);
      return result;
    }

    function renderEnemies(halfH) {
      const visible = getVisibleEnemies();
      const w = canvas.width;

      for (const obj of visible) {
        const { enemy, dist, diff } = obj;
        const screenX = (0.5 + (diff / FOV)) * w;
        const sprite = chooseBurglarFrame(enemy);
        if (!sprite) continue;

        const spriteHeight = (TILE_SIZE / dist) * 360;
        const spriteWidth  = spriteHeight * (sprite.width / sprite.height);
        const spriteY = halfH - spriteHeight/2 + spriteHeight*0.15;
        const spriteX = screenX - spriteWidth/2;

        const leftCol  = Math.max(0, Math.floor(spriteX));
        const rightCol = Math.min(NUM_RAYS - 1, Math.floor(spriteX + spriteWidth));
        let blocked = true;
        const correctedEnemyDist = dist * Math.cos(diff);
        for (let col = leftCol; col <= rightCol; col++) {
          if (depthBuffer[col] > correctedEnemyDist) { blocked = false; break; }
        }
        if (blocked) continue;

        ctx.drawImage(sprite, spriteX, spriteY, spriteWidth, spriteHeight);
      }
    }

    /**********************
     * HUD DRAW (inventory bar)
     **********************/
    function renderHUD() {
      const w = canvas.width, h = canvas.height;
      const hudHeight = 90;
      const hudTop = h - hudHeight;

      if (isImgReady(hud.bar)) ctx.drawImage(hud.bar, 0, hudTop, w, hudHeight);
      else { ctx.fillStyle = "#222"; ctx.fillRect(0, hudTop, w, hudHeight); }

      const columns = 7;
      const colW = w / columns;
      const centerY = hudTop + hudHeight / 2;

      // tribrach + battery smaller
      const ITEM_DRAW = [
        { scale: 0.50, slot: 0 }, // BRX72
        { scale: 0.50, slot: 1 }, // Data collector
        { scale: 0.30, slot: 2 }, // Tribrach smaller
        { scale: 0.30, slot: 4 }, // Battery smaller
        { scale: 0.45, slot: 5 }  // BRX71
      ];

      for (let i = 0; i < 5; i++) {
        if (itemsCollected > i && isImgReady(hud.items[i])) {
          const img = hud.items[i];
          const cfg = ITEM_DRAW[i];

          const maxW = colW * 0.72;
          const maxH = hudHeight * 0.72;

          let iw = img.width * cfg.scale;
          let ih = img.height * cfg.scale;

          const clamp = Math.min(1, maxW / iw, maxH / ih);
          iw *= clamp; ih *= clamp;

          const cx = colW * (cfg.slot + 0.5);
          ctx.drawImage(img, cx - iw/2, centerY - ih/2, iw, ih);
        }
      }

      // face
      let faceImg = null;
      if (punchState.active && punchState.time < punchState.duration * 0.5 && isImgReady(hud.angryFace)) faceImg = hud.angryFace;
      else if (isImgReady(hud.happyFace)) faceImg = hud.happyFace;

      if (faceImg) {
        const scale = 0.07;
        const iw = faceImg.width * scale, ih = faceImg.height * scale;
        const cx = colW * (3 + 0.5);
        ctx.drawImage(faceImg, cx - iw/2, centerY - ih/2, iw, ih);
      }

      // timer
      const timerX = colW * (6 + 0.5);
      const totalSeconds = Math.max(0, Math.floor(remainingTime));
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const timeStr = `${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;

      ctx.font = "28px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#ff3333";
      ctx.fillText(timeStr, timerX, centerY + 4);
    }

    /**********************
     * UPDATE
     **********************/
    function update(dt) {
      // Loading state (don’t run logic)
      if (!areAssetsReady()) return;

      if (gameState === "levelCompleteDelay") {
        levelCompleteDelay -= dt;
        if (levelCompleteDelay <= 0) gameState = "levelComplete";
        return;
      }

      if (gameState !== "running") {
        if (punchState.active) {
          punchState.time += dt;
          if (punchState.time >= punchState.duration) {
            punchState.active = false;
            punchState.time = 0;
            punchState.justHit = false;
          }
        }
        return;
      }

      // feedback timers
      hitMarkerT = Math.max(0, hitMarkerT - dt);
      shakeT = Math.max(0, shakeT - dt);
      hitVignetteT = Math.max(0, hitVignetteT - dt);

      // Smooth joystick filtering (big reduction in twitch)
      const a = 1 - Math.exp(-JOY_SMOOTH * dt);
      joyFiltered.x += (joy.x - joyFiltered.x) * a;
      joyFiltered.y += (joy.y - joyFiltered.y) * a;

      // Turn input (keyboard + joystick)
      const turnLeft  = keys["ArrowLeft"] || keys["KeyA"];
      const turnRight = keys["ArrowRight"]|| keys["KeyD"];

      let turnInput = 0;
      if (turnLeft) turnInput -= 1;
      if (turnRight) turnInput += 1;

      // joystick adds turn (x)
      turnInput += joyFiltered.x * JOY_TURN_SCALE;

      // Apply accel
      turnVel += turnInput * TURN_ACCEL * dt;

      // Damping when no input (or very small joystick)
      if (Math.abs(turnInput) < 0.03) {
        const drag = TURN_FRICTION * dt;
        if (turnVel > 0) turnVel = Math.max(0, turnVel - drag);
        else turnVel = Math.min(0, turnVel + drag);
      }

      turnVel = Math.max(-TURN_MAX, Math.min(TURN_MAX, turnVel));
      player.angle += turnVel * dt;

      // Move input (keyboard + joystick)
      const forward = keys["ArrowUp"] || keys["KeyW"];
      const back    = keys["ArrowDown"] || keys["KeyS"];

      let moveInput = 0;
      if (forward) moveInput += 1;
      if (back)    moveInput -= 1;

      // joystick adds forward/back (negative y = forward)
      moveInput += (-joyFiltered.y) * JOY_MOVE_SCALE;

      // clamp moveInput to [-1..1]
      moveInput = Math.max(-1, Math.min(1, moveInput));

      moveVel += moveInput * MOVE_ACCEL * dt;

      if (Math.abs(moveInput) < 0.03) {
        const drag = MOVE_FRICTION * dt;
        if (moveVel > 0) moveVel = Math.max(0, moveVel - drag);
        else moveVel = Math.min(0, moveVel + drag);

      }

      moveVel = Math.max(-MOVE_MAX, Math.min(MOVE_MAX, moveVel));

      const dx = Math.cos(player.angle) * moveVel * dt;
      const dy = Math.sin(player.angle) * moveVel * dt;

      const newX = player.x + dx;
      const newY = player.y + dy;

      if (!isSolid(newX, player.y)) player.x = newX;
      if (!isSolid(player.x, newY)) player.y = newY;

      // punch animation timing
      if (punchState.active) {
        punchState.time += dt;
        if (punchState.time >= punchState.duration) {
          punchState.active = false;
          punchState.time = 0;
          punchState.justHit = false;
        }
      }

      updateEnemies(dt);

      // timer
      remainingTime -= dt;
      if (remainingTime <= 0) {
        remainingTime = 0;
        if (itemsCollected >= totalItems) {
          gameState = "levelCompleteDelay";
          levelCompleteDelay = 2.0;
        } else if (!continueUsed) {
          gameState = "continuePrompt";
        } else {
          gameState = "gameOver";
        }
      }

      // win
      if (itemsCollected >= totalItems && gameState === "running") {
        gameState = "levelCompleteDelay";
        levelCompleteDelay = 2.0;
      }
    }

    /**********************
     * RENDER
     **********************/
    function renderGame() {
      const w = canvas.width, h = canvas.height;
      const halfH = h / 2;

      ctx.clearRect(0, 0, w, h);

      // screen shake
      ctx.save();
      if (shakeT > 0) {
        const s = (shakeT / 0.10);
        const mag = shakeMag * s;
        ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
      }

      // ceiling
      const ceilingGrad = ctx.createLinearGradient(0, 0, 0, halfH);
      ceilingGrad.addColorStop(0, "#101015");
      ceilingGrad.addColorStop(1, "#181820");
      ctx.fillStyle = ceilingGrad;
      ctx.fillRect(0, 0, w, halfH);

      // floor (perspective)
      renderFloorPerspective(halfH);

      // walls
      for (let i = 0; i < NUM_RAYS; i++) {
        const rayScreenPos = i / NUM_RAYS - 0.5;
        const rayAngle = player.angle + rayScreenPos * FOV;

        const { distance, tile, hitMapX, hitMapY, worldX, worldY } = castRay(rayAngle);
        if (tile === 0) { depthBuffer[i] = MAX_DEPTH; continue; }

        const corrected = distance * Math.cos(rayAngle - player.angle);
        depthBuffer[i] = corrected;

        const wallHeight = (TILE_SIZE / corrected) * 220;
        const colHeight = wallHeight;
        const colY = halfH - colHeight / 2;

        const texIndex = ((hitMapX + hitMapY) % wallTextures.length + wallTextures.length) % wallTextures.length;
        const tex = wallTextures[texIndex];

        if (isImgReady(tex)) {
          const texW = tex.width, texH = tex.height;

          const hitXmod = ((worldX % TILE_SIZE) + TILE_SIZE) % TILE_SIZE;
          const hitYmod = ((worldY % TILE_SIZE) + TILE_SIZE) % TILE_SIZE;

          let u;
          if (hitXmod < 1 || hitXmod > TILE_SIZE - 1) u = hitYmod / TILE_SIZE;
          else u = hitXmod / TILE_SIZE;

          const texX = Math.floor(u * texW);
          ctx.drawImage(tex, texX, 0, 1, texH, i, colY, 1, colHeight);
        } else {
          ctx.fillStyle = "#7a3b2e";
          ctx.fillRect(i, colY, 1, colHeight);
        }

        const shadow = Math.min(0.8, corrected / (MAX_DEPTH * 0.9));
        ctx.save();
        ctx.globalAlpha = shadow;
        ctx.fillStyle = "#000";
        ctx.fillRect(i, colY, 1, colHeight);
        ctx.restore();
      }

      // enemies
      renderEnemies(halfH);

      // fist (before HUD)
      const frame = getPunchFrame();
      if (frame && isImgReady(frame)) {
        const hudHeight = 90;
        const scale = 2.2;
        const imgW = frame.width * scale;
        const imgH = frame.height * scale;
        const x = w / 2 - imgW / 2 + 60;
        const y = h - hudHeight - imgH + 35;
        ctx.drawImage(frame, x, y, imgW, imgH);
      }

      // minimap

      const miniScale = 5, offsetX = 10, offsetY = 10;
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          const t = tileAt(x, y);
          ctx.fillStyle = (t === 0) ? "#202020" : "#7a3b2e";
          ctx.fillRect(offsetX + x * miniScale, offsetY + y * miniScale, miniScale, miniScale);
        }
      }

      for (const enemy of enemies) {
        const ex = offsetX + (enemy.x / TILE_SIZE) * miniScale;
        const ey = offsetY + (enemy.y / TILE_SIZE) * miniScale;
        ctx.fillStyle = (enemy.state === "dead" || enemy.state === "dying" || enemy.state === "finalHit") ? "#aa0000" : "#ff4444";
        ctx.fillRect(ex - 2, ey - 2, 4, 4);
      }

      const px = offsetX + (player.x / TILE_SIZE) * miniScale;
      const py = offsetY + (player.y / TILE_SIZE) * miniScale;
      ctx.fillStyle = "#00ff88";
      ctx.fillRect(px - 2, py - 2, 4, 4);

      ctx.strokeStyle = "#00ff88";
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px + Math.cos(player.angle) * 10, py + Math.sin(player.angle) * 10);
      ctx.stroke();

      // HUD bar
      renderHUD();

      // Crosshair (center dot)
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(w/2, h/2, 2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // Hit marker X
      if (hitMarkerT > 0) {
        const a = hitMarkerT / 0.15;
        const size = 10;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/2 - size, h/2 - size);
        ctx.lineTo(w/2 + size, h/2 + size);
        ctx.moveTo(w/2 + size, h/2 - size);
        ctx.lineTo(w/2 - size, h/2 + size);
        ctx.stroke();
        ctx.restore();
      }

      // Vignette (time low + hit flash)
      const lowTime = remainingTime <= 15 ? (1 - remainingTime / 15) : 0;
      const hitFlash = hitVignetteT > 0 ? (hitVignetteT / 0.18) : 0;
      const vig = Math.min(0.65, lowTime * 0.45 + hitFlash * 0.35);

      if (vig > 0) {
        const g = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.15, w/2, h/2, Math.max(w,h)*0.7);
        g.addColorStop(0, "rgba(255,0,0,0)");
        g.addColorStop(1, `rgba(255,0,0,${vig})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
      }

      ctx.restore(); // end shake
    }

    function render() {
      if (!areAssetsReady()) {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Loading…", canvas.width / 2, canvas.height / 2);
        return;
      }

      if (gameState === "title") { drawFullScreenImage(screenImages.title); return; }
      if (gameState === "prescreen") { drawFullScreenImage(screenImages.prescreen); return; }

      renderGame();

      if (gameState === "levelComplete") drawFullScreenImage(screenImages.complete);
      else if (gameState === "continuePrompt") drawFullScreenImage(screenImages.continue);
      else if (gameState === "gameOver") drawFullScreenImage(screenImages.gameover);
    }

    /**********************
     * MAIN LOOP (CRASH-PROOF, but no black flash unless actual error)
     **********************/
    let lastTime = performance.now();

    function loop(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      try {
        update(dt);
        render();
      } catch (err) {
        console.error(err);
        // Keep last frame visible, just overlay text (no full black flash)
        ctx.save();
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#ff7777";
        ctx.font = "16px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Game error, check console (F12).", canvas.width/2, canvas.height/2);
        ctx.restore();
      }

      requestAnimationFrame(loop);
    }

    /**********************
     * STARTUP
     **********************/
    updateStatusText();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
