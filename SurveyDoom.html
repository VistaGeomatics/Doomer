<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Warehouse Run – Stolen Property Hunt</title>

  <!-- Prevent mobile pinch/auto zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;           /* prevents page bounce/zoom feel */
      background: #000;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;         /* prevents browser gestures */
      -webkit-text-size-adjust: 100%;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    #title {
      margin-top: 8px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 14px;
      color: #888;
      user-select: none;
    }

    #game-container {
      width: 100%;
      display: flex;
      justify-content: center;
      padding-top: 8px;
    }

    canvas {
      border: 2px solid #444;
      background: #000;
      display: block;
      touch-action: none;
    }

    #hud {
      width: 100%;
      max-width: 980px;
      text-align: center;
      margin-top: 6px;
      font-size: 14px;
      color: #bbb;
      padding-bottom: 130px; /* room for touch controls */
      user-select: none;
    }

    #controls { font-size: 12px; color: #777; }
    #objective { font-size: 13px; color: #aaa; margin-top: 4px; }
    #status { margin-top: 6px; }

    /* Hide extra HUD text on small mobile to give canvas more room */
    @media (max-width: 900px) and (pointer:coarse) {
      #controls, #objective { display: none; }
      #hud { padding-bottom: 135px; margin-top: 0; }
      #title { margin-top: 6px; font-size: 12px; }
    }

    /* ---------------- MOBILE CONTROLS ---------------- */
    #touch-controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 130px;
      display: none;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px 16px;
      z-index: 50;
      pointer-events: none;
      background: linear-gradient(to top, rgba(0,0,0,0.35), rgba(0,0,0,0));
    }

    .left-controls, .right-controls {
      pointer-events: auto;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
    }

    .joystick {
      width: 132px;
      height: 132px;
      border-radius: 999px;
      position: relative;
      border: 2px solid rgba(255,255,255,0.08);
      background: rgba(30,30,35,0.20); /* more transparent */
      box-shadow: 0 10px 24px rgba(0,0,0,0.30);
      touch-action: none;
      overflow: hidden;
    }

    .joystick::after {
      content: "";
      position: absolute;
      inset: 18px;
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,0.08);
      opacity: 0.7;
    }

    .stick {
      width: 54px;
      height: 54px;
      border-radius: 999px;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 2px solid rgba(255,255,255,0.10);
      background: rgba(220,220,240,0.14); /* more transparent */
      box-shadow: 0 8px 16px rgba(0,0,0,0.30);
      touch-action: none;
    }

    .punch {
      width: 112px;
      height: 112px;
      border-radius: 26px;
      border: 2px solid rgba(255,255,255,0.10);
      background: rgba(120,25,25,0.22); /* more transparent */
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      letter-spacing: 0.04em;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 12px 26px rgba(0,0,0,0.35);
      touch-action: none;
    }

    .punch:active {
      transform: translateY(1px);
      background: rgba(170,30,30,0.30);
    }
  </style>
</head>

<body>
  <div id="title">WAREHOUSE RUN – STOLEN GPS</div>

  <div id="game-container">
    <canvas id="game"></canvas>
  </div>

  <div id="hud">
    <div id="controls">
      W / S – Move &nbsp; | &nbsp; A / D or ← / → – Turn &nbsp; | &nbsp; Space – Punch &nbsp; | &nbsp; Q – Floor Quality
    </div>
    <div id="objective">Objective: Retrieve all 5 GPS components before time runs out.</div>
    <div id="status"></div>
  </div>

  <div id="touch-controls" aria-label="Mobile controls">
    <div class="left-controls">
      <div class="joystick" id="joystick">
        <div class="stick" id="stick"></div>
      </div>
    </div>

    <div class="right-controls">
      <div class="punch" id="btn-punch" title="Punch">PUNCH</div>
    </div>
  </div>

  <audio id="bgm" src="the-metal-loop-full.wav" loop></audio>

  <script>
    /**********************
     * BASIC SETUP
     **********************/
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const bgm = document.getElementById("bgm");

    const BASE_W = 960;
    const BASE_H = 540;
    canvas.width = BASE_W;
    canvas.height = BASE_H;

    function loadImage(path) { const img = new Image(); img.src = path; return img; }
    function isImgReady(img) { return !!(img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0); }
    function drawFullScreenImage(img) {
      const w = canvas.width, h = canvas.height;
      if (!isImgReady(img)) { ctx.fillStyle="#000"; ctx.fillRect(0,0,w,h); return; }
      ctx.drawImage(img, 0, 0, w, h);
    }

    /**********************
     * RESPONSIVE CANVAS FIT (bigger on mobile)
     **********************/
    const touchControlsEl = document.getElementById("touch-controls");
    const isTouch = window.matchMedia("(pointer:coarse)").matches || navigator.maxTouchPoints > 0;
    if (isTouch) touchControlsEl.style.display = "flex";

    function fitCanvasToScreen() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const titleH = document.getElementById("title").offsetHeight + 8;
      const controlsH = isTouch ? 130 : 0;

      // Reserve only what we must (title + controls). This makes the game fill mobile.
      const reserve = titleH + controlsH + (isTouch ? 8 : 16);

      const availW = vw;
      const availH = Math.max(200, vh - reserve);

      const aspect = BASE_W / BASE_H;

      let cssH = availH;
      let cssW = cssH * aspect;

      if (cssW > availW) {
        cssW = availW;
        cssH = cssW / aspect;
      }

      canvas.style.width = Math.floor(cssW) + "px";
      canvas.style.height = Math.floor(cssH) + "px";
    }

    window.addEventListener("resize", fitCanvasToScreen);
    window.addEventListener("orientationchange", () => setTimeout(fitCanvasToScreen, 120));
    fitCanvasToScreen();

    /**********************
     * GAME STATE
     **********************/
    let gameState = "title";
    let continueUsed = false;

    const LEVEL_TIME = 120;
    let remainingTime = LEVEL_TIME;
    let levelCompleteDelay = 0;

    const screenImages = {
      title: loadImage("Level3.png"),
      prescreen: loadImage("Prescreen.png"),
      complete: loadImage("level complete.png"),
      gameover: loadImage("Fail.png"),
      continue: loadImage("Continue.png")
    };

    /**********************
     * MUSIC / SFX
     **********************/
    let bgmStarted = false;
    function startBgm() {
      if (bgmStarted || !bgm) return;
      bgm.volume = 0.3;
      bgm.play().catch(() => {});
      bgmStarted = true;
    }

    const punchSound = new Audio("Punch.wav");
    punchSound.volume = 1.0;

    /**********************
     * FEEDBACK
     **********************/
    let hitMarkerT = 0;
    let shakeT = 0;
    let shakeMag = 0;
    let hitVignetteT = 0;

    /**********************
     * MOVEMENT SMOOTHING
     **********************/
    let moveVel = 0;
    let turnVel = 0;

    const MOVE_ACCEL = 900;
    const MOVE_FRICTION = 1200;
    const MOVE_MAX = 170;

    const TURN_ACCEL = 10.0;
    const TURN_FRICTION = 14.0;
    const TURN_MAX = 2.8;

    /**********************
     * MAP
     **********************/
    const asciiMap = [
      "################################",
      "#...............##............#",
      "#....#####......##....#####...#",
      "#..###....####....####....###.#",
      "#..######.....................#",
      "#..######....######...........#",
      "#..######....######....#####..#",
      "#..###....####....####....###.#",
      "#.....####.....####.....####..#",
      "#..###....####....####....###.#",
      "#..###........P.........###...#",
      "#..###....####....####....###.#",
      "#.....####.....####.....####..#",
      "#..###....####....####....###.#",
      "#..######.....................#",
      "#..######....######...........#",
      "#..######....######....#####..#",
      "#..###....####....####....###.#",
      "#...............##............#",
      "#...............##............#",
      "################################"
    ];

    const MAP_HEIGHT = asciiMap.length;
    const MAP_WIDTH  = asciiMap[0].length;

    const map = asciiMap.map(row => row.split("").map(ch => (ch === "." || ch === "P") ? 0 : 1));
    const TILE_SIZE = 64;

    function tileAt(tx, ty) {
      if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) return 1;
      return map[ty][tx];
    }

    function isSolid(px, py) {
      const tx = Math.floor(px / TILE_SIZE);
      const ty = Math.floor(py / TILE_SIZE);
      return tileAt(tx, ty) !== 0;
    }

    /**********************
     * PLAYER
     **********************/
    let spawnX = 1.5, spawnY = 1.5;
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (asciiMap[y][x] === "P") { spawnX = x + 0.5; spawnY = y + 0.5; }
      }
    }

    const player = { x: spawnX * TILE_SIZE, y: spawnY * TILE_SIZE, angle: 0 };

    const FOV = Math.PI / 3;
    const NUM_RAYS = canvas.width;
    const MAX_DEPTH = 18 * TILE_SIZE;
    const depthBuffer = new Array(NUM_RAYS);

    /**********************
     * INPUT
     **********************/
    const keys = {};

    // Joystick output (-1..1)
    const joy = { x: 0, y: 0, active: false };

    // Make joystick MUCH less touchy:
    const JOY_DEADZONE = 0.22;     // bigger deadzone
    const joyRadius = 60;          // more travel so it's controllable
    const JOY_TURN_SCALE = 0.55;   // smaller turning contribution
    const JOY_MOVE_SCALE = 0.90;   // movement can stay stronger
    const JOY_CURVE_EXP = 1.7;     // non-linear curve to soften near center

    function curve(v) {
      const s = Math.sign(v);
      const a = Math.abs(v);
      return s * Math.pow(a, JOY_CURVE_EXP);
    }

    // Floor quality toggle
    let FLOOR_RES = 2;

    window.addEventListener("keydown", (e) => {
      startBgm();
      if (!keys[e.code]) {
        if (e.code === "Space") handlePrimaryAction();
      }
      if (e.code === "KeyQ") {
        FLOOR_RES = (FLOOR_RES === 1) ? 2 : (FLOOR_RES === 2) ? 3 : 1;
        rebuildFloorBuffer();
      }
      keys[e.code] = true;
    });

    window.addEventListener("keyup", (e) => { keys[e.code] = false; });

    function handlePrimaryAction() {
      if (gameState === "running" && !punchState.active) { startPunch(); return; }
      if (gameState === "title") { gameState = "prescreen"; return; }
      if (gameState === "prescreen") { startLevel(); return; }
      if (gameState === "continuePrompt") {
        if (!continueUsed) { continueUsed = true; startLevel(); }
        return;
      }
      if (gameState === "levelComplete" || gameState === "gameOver") resetGameCompletely();
    }

    // Tap canvas: advance screens (avoid accidental punch on touch)
    canvas.addEventListener("pointerdown", (e) => {
      startBgm();
      e.preventDefault();
      if (gameState !== "running") handlePrimaryAction();
    }, { passive:false });

    /**********************
     * JOYSTICK (touch)
     **********************/
    const joystickEl = document.getElementById("joystick");
    const stickEl = document.getElementById("stick");

    let joyPointerId = null;
    let joyCenter = { x: 0, y: 0 };

    function setStickVisual(nx, ny) {
      const px = nx * joyRadius;
      const py = ny * joyRadius;
      stickEl.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`;
    }

    function setJoy(nx, ny) {
      // clamp
      const mag = Math.hypot(nx, ny);
      if (mag > 1) { nx /= mag; ny /= mag; }

      // deadzone
      const m = Math.hypot(nx, ny);
      if (m < JOY_DEADZONE) {
        joy.x = 0; joy.y = 0;
        setStickVisual(0, 0);
        return;
      }

      // scale out of deadzone
      const scaled = Math.min(1, (m - JOY_DEADZONE) / (1 - JOY_DEADZONE));
      const ux = nx / m;
      const uy = ny / m;

      // apply non-linear curve
      joy.x = curve(ux * scaled);
      joy.y = curve(uy * scaled);

      setStickVisual(joy.x, joy.y);
    }

    if (isTouch) {
      joystickEl.addEventListener("pointerdown", (e) => {
        startBgm();
        e.preventDefault();
        joyPointerId = e.pointerId;
        joy.active = true;

        const r = joystickEl.getBoundingClientRect();
        joyCenter.x = r.left + r.width / 2;
        joyCenter.y = r.top + r.height / 2;

        joystickEl.setPointerCapture(e.pointerId);

        setJoy((e.clientX - joyCenter.x) / joyRadius, (e.clientY - joyCenter.y) / joyRadius);
      }, { passive:false });

      joystickEl.addEventListener("pointermove", (e) => {
        if (!joy.active || e.pointerId !== joyPointerId) return;
        e.preventDefault();
        setJoy((e.clientX - joyCenter.x) / joyRadius, (e.clientY - joyCenter.y) / joyRadius);
      }, { passive:false });

      const joyUp = (e) => {
        if (e.pointerId !== joyPointerId) return;
        e.preventDefault();
        joy.active = false;
        joyPointerId = null;
        joy.x = 0; joy.y = 0;
        setStickVisual(0, 0);
      };

      joystickEl.addEventListener("pointerup", joyUp, { passive:false });
      joystickEl.addEventListener("pointercancel", joyUp, { passive:false });
    }

    // Punch button (also prevents iOS zoom-jank)
    (function bindPunchOnce(){
      const el = document.getElementById("btn-punch");
      let pressed = false;

      el.addEventListener("pointerdown", (ev) => {
        startBgm();
        ev.preventDefault();
        ev.stopPropagation();
        if (pressed) return;
        pressed = true;

        if (gameState === "running") {
          if (!punchState.active) startPunch();
        } else {
          handlePrimaryAction();
        }
      }, { passive:false });

      const release = (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        pressed = false;
      };

      el.addEventListener("pointerup", release, { passive:false });
      el.addEventListener("pointercancel", release, { passive:false });
      el.addEventListener("pointerleave", release, { passive:false });
    })();

    /**********************
     * ENEMIES / ITEMS
     **********************/
    const enemies = [
      { x: (6.5)  * TILE_SIZE, y: (3.5)  * TILE_SIZE },
      { x: (22.5) * TILE_SIZE, y: (3.5)  * TILE_SIZE },
      { x: (6.5)  * TILE_SIZE, y: (13.5) * TILE_SIZE },
      { x: (22.5) * TILE_SIZE, y: (13.5) * TILE_SIZE },
      { x: (15.5) * TILE_SIZE, y: (9.5)  * TILE_SIZE }
    ].map(e => ({
      ...e,
      alive: true,
      health: 3,
      state: "alive",
      deathTimer: 0,
      finalHitTimer: 0,
      dir: Math.random() * Math.PI * 2,
      turnTimer: 1 + Math.random() * 2,
      animTime: 0,
      animFrame: 0,
      moving: false,
      movingAway: false,
      prevDistToPlayer: 0,
      hitTimer: 0
    }));

    const ENEMY_SPEED = 55;
    const ENEMY_AVOID_RADIUS = 4 * TILE_SIZE;
    const ENEMY_ANIM_FRAME_TIME = 0.16;

    let itemsCollected = 0;
    const totalItems = enemies.length;

    function updateStatusText() {
      statusEl.textContent = (itemsCollected >= totalItems)
        ? "All GPS components recovered!"
        : `GPS components recovered: ${itemsCollected} / ${totalItems}`;
    }
    updateStatusText();

    function resetEnemies() {
      const positions = [
        { x: (6.5)  * TILE_SIZE, y: (3.5)  * TILE_SIZE },
        { x: (22.5) * TILE_SIZE, y: (3.5)  * TILE_SIZE },
        { x: (6.5)  * TILE_SIZE, y: (13.5) * TILE_SIZE },
        { x: (22.5) * TILE_SIZE, y: (13.5) * TILE_SIZE },
        { x: (15.5) * TILE_SIZE, y: (9.5)  * TILE_SIZE }
      ];
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i], p = positions[i];
        e.x = p.x; e.y = p.y;
        e.alive = true; e.health = 3; e.state = "alive";
        e.deathTimer = 0; e.finalHitTimer = 0;
        e.dir = Math.random() * Math.PI * 2;
        e.turnTimer = 1 + Math.random() * 2;
        e.animTime = 0; e.animFrame = 0;
        e.moving = false; e.movingAway = false;
        e.prevDistToPlayer = 0; e.hitTimer = 0;
      }
    }

    function startLevel() {
      gameState = "running";
      remainingTime = LEVEL_TIME;
      levelCompleteDelay = 0;

      player.x = spawnX * TILE_SIZE;
      player.y = spawnY * TILE_SIZE;
      player.angle = 0;

      moveVel = 0;
      turnVel = 0;

      resetEnemies();
      itemsCollected = 0;
      updateStatusText();
    }

    function resetGameCompletely() {
      continueUsed = false;
      itemsCollected = 0;
      remainingTime = LEVEL_TIME;
      levelCompleteDelay = 0;

      resetEnemies();
      player.x = spawnX * TILE_SIZE;
      player.y = spawnY * TILE_SIZE;
      player.angle = 0;

      moveVel = 0;
      turnVel = 0;

      gameState = "title";
      updateStatusText();
    }

    function updateEnemies(dt) {
      for (const e of enemies) {
        if (e.state === "finalHit") {
          e.finalHitTimer -= dt;
          if (e.finalHitTimer <= 0) { e.state = "dying"; e.deathTimer = 0.6; }
          continue;
        }
        if (e.state === "dying") {
          e.deathTimer -= dt;
          if (e.deathTimer <= 0) e.state = "dead";
          continue;
        }
        if (e.state === "dead") continue;

        if (e.hitTimer > 0) {
          e.hitTimer -= dt;
          if (e.hitTimer < 0) e.hitTimer = 0;
        }

        const dx0 = player.x - e.x;
        const dy0 = player.y - e.y;
        const d0 = Math.hypot(dx0, dy0);
        e.prevDistToPlayer = d0;

        if (d0 < ENEMY_AVOID_RADIUS) {
          const a = Math.atan2(dy0, dx0);
          e.dir = a + Math.PI + (Math.random() - 0.5) * 0.4;
          e.turnTimer = 0.3;
        } else {
          e.turnTimer -= dt;
          if (e.turnTimer <= 0) {
            e.dir = Math.random() * Math.PI * 2;
            e.turnTimer = 1 + Math.random() * 2;
          }
        }

        const dx = Math.cos(e.dir) * ENEMY_SPEED * dt;
        const dy = Math.sin(e.dir) * ENEMY_SPEED * dt;

        const oldX = e.x, oldY = e.y;

        const nx = e.x + dx;
        const ny = e.y + dy;

        if (!isSolid(nx, e.y)) e.x = nx; else e.dir = Math.random() * Math.PI * 2;
        if (!isSolid(e.x, ny)) e.y = ny; else e.dir = Math.random() * Math.PI * 2;

        e.moving = Math.hypot(e.x - oldX, e.y - oldY) > 0.5;

        const dx1 = player.x - e.x;
        const dy1 = player.y - e.y;
        const d1 = Math.hypot(dx1, dy1);
        e.movingAway = d1 > e.prevDistToPlayer + 1;

        if (e.moving) {
          e.animTime += dt;
          if (e.animTime >= ENEMY_ANIM_FRAME_TIME) {
            e.animTime = 0;
            e.animFrame = 1 - e.animFrame;
          }
        } else {
          e.animTime = 0;
          e.animFrame = 0;
        }
      }
    }

    /**********************
     * PUNCH
     **********************/
    const punchState = { active:false, time:0, duration:0.25, justHit:false };
    const PUNCH_RANGE = 1.5 * TILE_SIZE;
    const PUNCH_ARC   = Math.PI / 4;

    function normalizeAngle(a) {
      while (a < -Math.PI) a += 2*Math.PI;
      while (a >  Math.PI) a -= 2*Math.PI;
      return a;
    }

    function startPunch() {
      punchState.active = true;
      punchState.time = 0;
      punchState.justHit = false;

      if (navigator.vibrate) navigator.vibrate(20);
      try { punchSound.currentTime = 0; punchSound.play().catch(() => {}); } catch {}

      performPunch();
    }

    function performPunch() {
      let hitAny = false;

      for (const enemy of enemies) {
        if (enemy.state !== "alive") continue;

        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist > PUNCH_RANGE) continue;

        const angleTo = Math.atan2(dy, dx);
        const diff = normalizeAngle(angleTo - player.angle);
        if (Math.abs(diff) > PUNCH_ARC) continue;

        enemy.health -= 1;

        if (enemy.health > 0) {
          enemy.hitTimer = 0.2;
        } else {
          enemy.alive = false;
          enemy.state = "finalHit";
          enemy.finalHitTimer = 0.2;
          enemy.hitTimer = 0;
          itemsCollected++;
        }

        hitAny = true;
      }

      punchState.justHit = hitAny;

      if (hitAny) {
        hitMarkerT = 0.15;
        shakeT = 0.12;
        shakeMag = 6;
        hitVignetteT = 0.20;
        updateStatusText();
      }
    }

    const punchImages = [];
    let punchImagesLoaded = 0;
    ["punch1.png", "punch2.png", "punch3.png"].forEach((file, idx) => {
      const img = new Image();
      img.src = file;
      img.onload = () => { punchImagesLoaded++; };
      punchImages[idx] = img;
    });

    function getPunchFrame() {
      if (!punchState.active || punchImagesLoaded === 0) return null;
      const t = punchState.time / punchState.duration;
      let frameIndex = 0;
      if (t > 0.4 && t <= 0.8) frameIndex = 1;
      else if (t > 0.8) frameIndex = 2;
      return isImgReady(punchImages[frameIndex]) ? punchImages[frameIndex] : null;
    }

    /**********************
     * TEXTURES
     **********************/
    const wallTextureFiles = ["Wall1.png", "Wall2.png", "wall3.png"];
    const wallTextures = wallTextureFiles.map(f => { const img = new Image(); img.src = f; return img; });

    const floorImg = new Image();
    floorImg.src = "floor 69.jpg";

    const floorTex = { ready:false, w:0, h:0, data:null };

    floorImg.onload = () => {
      const c = document.createElement("canvas");
      c.width = floorImg.width;
      c.height = floorImg.height;
      const cctx = c.getContext("2d", { willReadFrequently: true });
      cctx.drawImage(floorImg, 0, 0);
      const imgd = cctx.getImageData(0, 0, c.width, c.height);
      floorTex.ready = true;
      floorTex.w = c.width;
      floorTex.h = c.height;
      floorTex.data = imgd.data;
    };

    const floorBuf = document.createElement("canvas");
    const floorCtx = floorBuf.getContext("2d", { willReadFrequently: true });
    let floorFrame = null;

    function rebuildFloorBuffer() {
      floorBuf.width = Math.ceil(canvas.width / FLOOR_RES);
      floorBuf.height = Math.ceil((canvas.height / 2) / FLOOR_RES);
      floorFrame = floorCtx.createImageData(floorBuf.width, floorBuf.height);
    }
    rebuildFloorBuffer();

    const FLOOR_TEX_WORLD_SCALE = 0.22;

    function sampleFloorRGB(wx, wy) {
      if (!floorTex.ready || !floorTex.data) return [48,48,52];
      const tw = floorTex.w, th = floorTex.h;

      let tx = Math.floor(wx * FLOOR_TEX_WORLD_SCALE) % tw;
      let ty = Math.floor(wy * FLOOR_TEX_WORLD_SCALE) % th;
      if (tx < 0) tx += tw;
      if (ty < 0) ty += th;

      const idx = (ty * tw + tx) * 4;
      return [ floorTex.data[idx], floorTex.data[idx+1], floorTex.data[idx+2] ];
    }

    function renderFloorPerspective(halfH) {
      const w = canvas.width, h = canvas.height;

      if (!floorTex.ready || !floorFrame) {
        ctx.fillStyle = "#303033";
        ctx.fillRect(0, halfH, w, halfH);
        return;
      }

      const bw = floorBuf.width;
      const bh = floorBuf.height;
      const data = floorFrame.data;

      const leftA  = player.angle - FOV / 2;
      const rightA = player.angle + FOV / 2;

      const leftDX  = Math.cos(leftA);
      const leftDY  = Math.sin(leftA);
      const rightDX = Math.cos(rightA);
      const rightDY = Math.sin(rightA);

      const cameraHeight = 0.55 * TILE_SIZE;
      const projPlane = halfH;

      for (let yb = 0; yb < bh; yb++) {
        const screenY = halfH + (yb * FLOOR_RES);
        const p = (screenY - halfH);
        const rowDist = (cameraHeight * projPlane) / Math.max(1, p);

        const stepX = rowDist * (rightDX - leftDX) / bw;
        const stepY = rowDist * (rightDY - leftDY) / bw;

        let fx = player.x + rowDist * leftDX;
        let fy = player.y + rowDist * leftDY;

        const shade = Math.max(0.15, 1 - (rowDist / (MAX_DEPTH * 0.9)));

        for (let xb = 0; xb < bw; xb++) {
          const [r0,g0,b0] = sampleFloorRGB(fx, fy);
          const r = Math.floor(r0 * shade);
          const g = Math.floor(g0 * shade);
          const b = Math.floor(b0 * shade);

          const o = (yb * bw + xb) * 4;
          data[o] = r; data[o+1] = g; data[o+2] = b; data[o+3] = 255;

          fx += stepX;
          fy += stepY;
        }
      }

      floorCtx.putImageData(floorFrame, 0, 0);

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(floorBuf, 0, 0, bw, bh, 0, halfH, w, h - halfH);
      ctx.restore();
    }

    /**********************
     * SPRITES
     **********************/
    const burglarSprites = { standing:null, walk1:null, walk2:null, away:null, hit:null, falling:null, dead:null };
    function loadBurglarSprite(name, file) {
      const img = new Image();
      img.src = file;
      img.onload = () => { burglarSprites[name] = img; };
      return img;
    }
    loadBurglarSprite("standing","BGStanding.png");
    loadBurglarSprite("walk1","BGWalking1.png");
    loadBurglarSprite("walk2","BGwalking2.png");
    loadBurglarSprite("away","BGWalkingaway.png");
    loadBurglarSprite("hit","BGpunch.png");
    loadBurglarSprite("falling","Falling1.png");
    loadBurglarSprite("dead","Dead.png");

    function chooseBurglarFrame(enemy) {
      const standing = isImgReady(burglarSprites.standing) ? burglarSprites.standing : null;
      if (!standing) return null;

      const hit     = isImgReady(burglarSprites.hit)     ? burglarSprites.hit     : null;
      const falling = isImgReady(burglarSprites.falling) ? burglarSprites.falling : null;
      const dead    = isImgReady(burglarSprites.dead)    ? burglarSprites.dead    : null;
      const away    = isImgReady(burglarSprites.away)    ? burglarSprites.away    : null;
      const walk1   = isImgReady(burglarSprites.walk1)   ? burglarSprites.walk1   : null;
      const walk2   = isImgReady(burglarSprites.walk2)   ? burglarSprites.walk2   : null;

      if (enemy.state === "finalHit") return hit || standing;
      if (enemy.state === "dying")    return falling || standing;
      if (enemy.state === "dead")     return dead || standing;
      if (enemy.hitTimer > 0)         return hit || standing;

      if (!enemy.moving) return standing;
      if (enemy.movingAway && away) return away;
      if (enemy.animFrame === 0 && walk1) return walk1;
      if (enemy.animFrame === 1 && walk2) return walk2;
      return standing;
    }

    /**********************
     * HUD ASSETS
     **********************/
    const hud = { bar:null, items:[], happyFace:null, angryFace:null };
    hud.bar = loadImage("Bar.png");
    hud.items[0] = loadImage("BRX72.png");
    hud.items[1] = loadImage("Data collector copy.png");
    hud.items[2] = loadImage("Tribrachs.png");
    hud.items[3] = loadImage("battery copy.png");
    hud.items[4] = loadImage("BRX71.png");
    hud.happyFace = loadImage("Happy Face.png");
    hud.angryFace = loadImage("Angry face.png");

    function areAssetsReady() {
      if (!isImgReady(screenImages.title) || !isImgReady(screenImages.prescreen)) return false;
      if (!floorTex.ready) return false;
      if (!isImgReady(burglarSprites.standing)) return false;
      return true;
    }

    /**********************
     * RAYCAST
     **********************/
    function castRay(rayAngle) {
      rayAngle = (rayAngle + Math.PI*2) % (Math.PI*2);
      const sin = Math.sin(rayAngle), cos = Math.cos(rayAngle);

      const stepSize = 4;
      let rayX = player.x, rayY = player.y, distance = 0;
      let hitTile = 0, hitMapX = 0, hitMapY = 0;

      while (distance < MAX_DEPTH) {
        rayX += cos * stepSize;
        rayY += sin * stepSize;
        distance += stepSize;

        const tx = Math.floor(rayX / TILE_SIZE);
        const ty = Math.floor(rayY / TILE_SIZE);

        if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) {
          hitTile = 1; hitMapX = tx; hitMapY = ty; break;
        }

        const t = tileAt(tx, ty);
        if (t !== 0) { hitTile = t; hitMapX = tx; hitMapY = ty; break; }
      }

      return { distance, tile: hitTile, hitMapX, hitMapY, worldX: rayX, worldY: rayY };
    }

    /**********************
     * HUD DRAW (unchanged from your version logic)
     **********************/
    function renderHUD() {
      const w = canvas.width, h = canvas.height;
      const hudHeight = 90;
      const hudTop = h - hudHeight;

      if (isImgReady(hud.bar)) ctx.drawImage(hud.bar, 0, hudTop, w, hudHeight);
      else { ctx.fillStyle="#222"; ctx.fillRect(0, hudTop, w, hudHeight); }

      const columns = 7;
      const colW = w / columns;
      const centerY = hudTop + hudHeight / 2;

      const ITEM_DRAW = [
        { scale: 0.50, slot: 0 },
        { scale: 0.50, slot: 1 },
        { scale: 0.30, slot: 2 }, // Tribrach smaller
        { scale: 0.30, slot: 4 }, // Battery smaller
        { scale: 0.45, slot: 5 }
      ];

      for (let i = 0; i < 5; i++) {
        if (itemsCollected > i && isImgReady(hud.items[i])) {
          const img = hud.items[i];
          const cfg = ITEM_DRAW[i];

          const maxW = colW * 0.72;
          const maxH = hudHeight * 0.72;

          let iw = img.width * cfg.scale;
          let ih = img.height * cfg.scale;

          const clamp = Math.min(1, maxW / iw, maxH / ih);
          iw *= clamp; ih *= clamp;

          const cx = colW * (cfg.slot + 0.5);
          ctx.drawImage(img, cx - iw/2, centerY - ih/2, iw, ih);
        }
      }

      let faceImg = null;
      if (punchState.active && punchState.time < punchState.duration * 0.5 && isImgReady(hud.angryFace)) faceImg = hud.angryFace;
      else if (isImgReady(hud.happyFace)) faceImg = hud.happyFace;

      if (faceImg) {
        const scale = 0.07;
        const iw = faceImg.width * scale, ih = faceImg.height * scale;
        const cx = colW * (3 + 0.5);
        ctx.drawImage(faceImg, cx - iw/2, centerY - ih/2, iw, ih);
      }

      const timerX = colW * (6 + 0.5);
      const totalSeconds = Math.max(0, Math.floor(remainingTime));
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const timeStr = `${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;

      ctx.font = "28px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#ff3333";
      ctx.fillText(timeStr, timerX, centerY + 4);
    }

    /**********************
     * ENEMY RENDER
     **********************/
    function getVisibleEnemies() {
      const result = [];
      for (const enemy of enemies) {
        const dx = enemy.x - player.x, dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        const angleTo = Math.atan2(dy, dx);
        const diff = normalizeAngle(angleTo - player.angle);
        if (Math.abs(diff) > FOV/2) continue;
        result.push({ enemy, dist, diff });
      }
      result.sort((a,b) => b.dist - a.dist);
      return result;
    }

    function renderEnemies(halfH) {
      const visible = getVisibleEnemies();
      const w = canvas.width;

      for (const obj of visible) {
        const { enemy, dist, diff } = obj;
        const sprite = chooseBurglarFrame(enemy);
        if (!sprite || dist <= 1) continue;

        const screenX = (0.5 + (diff / FOV)) * w;

        const spriteHeight = (TILE_SIZE / dist) * 360;
        const ratio = sprite.width / sprite.height;
        if (!Number.isFinite(spriteHeight) || !Number.isFinite(ratio)) continue;

        const spriteWidth  = spriteHeight * ratio;
        const spriteY = halfH - spriteHeight/2 + spriteHeight*0.15;
        const spriteX = screenX - spriteWidth/2;

        const leftCol  = Math.max(0, Math.floor(spriteX));
        const rightCol = Math.min(NUM_RAYS - 1, Math.floor(spriteX + spriteWidth));
        let blocked = true;
        const correctedEnemyDist = dist * Math.cos(diff);
        for (let col = leftCol; col <= rightCol; col++) {
          if (depthBuffer[col] > correctedEnemyDist) { blocked = false; break; }
        }
        if (blocked) continue;

        ctx.drawImage(sprite, spriteX, spriteY, spriteWidth, spriteHeight);
      }
    }

    /**********************
     * UPDATE (with calmer joystick)
     **********************/
    function update(dt) {
      if (gameState === "levelCompleteDelay") {
        levelCompleteDelay -= dt;
        if (levelCompleteDelay <= 0) gameState = "levelComplete";
        return;
      }

      if (gameState !== "running") {
        if (punchState.active) {
          punchState.time += dt;
          if (punchState.time >= punchState.duration) {
            punchState.active = false;
            punchState.time = 0;
            punchState.justHit = false;
          }
        }
        return;
      }

      hitMarkerT = Math.max(0, hitMarkerT - dt);
      shakeT = Math.max(0, shakeT - dt);
      hitVignetteT = Math.max(0, hitVignetteT - dt);

      // Turn input (keyboard + joystick X, scaled down)
      const turnLeft  = keys["ArrowLeft"] || keys["KeyA"];
      const turnRight = keys["ArrowRight"]|| keys["KeyD"];

      let turnInput = 0;
      if (turnLeft) turnInput -= 1;
      if (turnRight) turnInput += 1;

      // joystick turning, MUCH calmer
      turnInput += (joy.x * JOY_TURN_SCALE);

      turnVel += turnInput * TURN_ACCEL * dt;

      if (Math.abs(turnInput) < 0.02) {
        const drag = TURN_FRICTION * dt;
        if (turnVel > 0) turnVel = Math.max(0, turnVel - drag);
        else turnVel = Math.min(0, turnVel + drag);
      }

      turnVel = Math.max(-TURN_MAX, Math.min(TURN_MAX, turnVel));
      player.angle += turnVel * dt;

      // Move input (keyboard + joystick Y)
      const forward = keys["ArrowUp"] || keys["KeyW"];
      const back    = keys["ArrowDown"] || keys["KeyS"];

      let moveInput = 0;
      if (forward) moveInput += 1;
      if (back)    moveInput -= 1;

      // joystick Y: up is negative
      moveInput += (-joy.y * JOY_MOVE_SCALE);

      moveVel += moveInput * MOVE_ACCEL * dt;

      if (Math.abs(moveInput) < 0.02) {
        const drag = MOVE_FRICTION * dt;
        if (moveVel > 0) moveVel = Math.max(0, moveVel - drag);
        else moveVel = Math.min(0, moveVel + drag);
      }

      moveVel = Math.max(-MOVE_MAX, Math.min(MOVE_MAX, moveVel));

      const dx = Math.cos(player.angle) * moveVel * dt;
      const dy = Math.sin(player.angle) * moveVel * dt;

      const newX = player.x + dx;
      const newY = player.y + dy;

      if (!isSolid(newX, player.y)) player.x = newX;
      if (!isSolid(player.x, newY)) player.y = newY;

      if (punchState.active) {
        punchState.time += dt;
        if (punchState.time >= punchState.duration) {
          punchState.active = false;
          punchState.time = 0;
          punchState.justHit = false;
        }
      }

      updateEnemies(dt);

      remainingTime -= dt;
      if (remainingTime <= 0) {
        remainingTime = 0;
        if (itemsCollected >= totalItems) {
          gameState = "levelCompleteDelay";
          levelCompleteDelay = 2.0;
        } else if (!continueUsed) {
          gameState = "continuePrompt";
        } else {
          gameState = "gameOver";
        }
      }

      if (itemsCollected >= totalItems && gameState === "running") {
        gameState = "levelCompleteDelay";
        levelCompleteDelay = 2.0;
      }
    }

    /**********************
     * RENDER
     **********************/
    function renderGame() {
      const w = canvas.width, h = canvas.height;
      const halfH = h / 2;

      ctx.clearRect(0, 0, w, h);

      ctx.save();
      if (shakeT > 0) {
        const s = (shakeT / 0.12);
        const mag = shakeMag * s;
        ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
      }

      const ceilingGrad = ctx.createLinearGradient(0, 0, 0, halfH);
      ceilingGrad.addColorStop(0, "#101015");
      ceilingGrad.addColorStop(1, "#181820");
      ctx.fillStyle = ceilingGrad;
      ctx.fillRect(0, 0, w, halfH);

      renderFloorPerspective(halfH);

      for (let i = 0; i < NUM_RAYS; i++) {
        const rayScreenPos = i / NUM_RAYS - 0.5;
        const rayAngle = player.angle + rayScreenPos * FOV;

        const { distance, tile, hitMapX, hitMapY, worldX, worldY } = castRay(rayAngle);
        if (tile === 0) { depthBuffer[i] = MAX_DEPTH; continue; }

        const corrected = distance * Math.cos(rayAngle - player.angle);
        depthBuffer[i] = corrected;

        const wallHeight = (TILE_SIZE / corrected) * 220;
        const colHeight = wallHeight;
        const colY = halfH - colHeight / 2;

        const texIndex = ((hitMapX + hitMapY) % wallTextures.length + wallTextures.length) % wallTextures.length;
        const tex = wallTextures[texIndex];

        if (isImgReady(tex)) {
          const texW = tex.width, texH = tex.height;

          const hitXmod = ((worldX % TILE_SIZE) + TILE_SIZE) % TILE_SIZE;
          const hitYmod = ((worldY % TILE_SIZE) + TILE_SIZE) % TILE_SIZE;

          let u;
          if (hitXmod < 1 || hitXmod > TILE_SIZE - 1) u = hitYmod / TILE_SIZE;
          else u = hitXmod / TILE_SIZE;

          const texX = Math.floor(u * texW);
          ctx.drawImage(tex, texX, 0, 1, texH, i, colY, 1, colHeight);
        } else {
          ctx.fillStyle = "#7a3b2e";
          ctx.fillRect(i, colY, 1, colHeight);
        }

        const shadow = Math.min(0.8, corrected / (MAX_DEPTH * 0.9));
        ctx.save();
        ctx.globalAlpha = shadow;
        ctx.fillStyle = "#000";
        ctx.fillRect(i, colY, 1, colHeight);
        ctx.restore();
      }

      renderEnemies(halfH);

      const frame = getPunchFrame();
      if (frame) {
        const hudHeight = 90;
        const scale = 2.2;
        const imgW = frame.width * scale;
        const imgH = frame.height * scale;
        const x = w / 2 - imgW / 2 + 60;
        const y = h - hudHeight - imgH + 35;
        ctx.drawImage(frame, x, y, imgW, imgH);
      }

      renderHUD();

      // Crosshair dot
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(w/2, h/2, 2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // Hit marker X
      if (hitMarkerT > 0) {
        const a = hitMarkerT / 0.15;
        const size = 10;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/2 - size, h/2 - size);
        ctx.lineTo(w/2 + size, h/2 + size);
        ctx.moveTo(w/2 + size, h/2 - size);
        ctx.lineTo(w/2 - size, h/2 + size);
        ctx.stroke();
        ctx.restore();
      }

      // Vignette
      const lowTime = remainingTime <= 15 ? (1 - remainingTime / 15) : 0;
      const hitFlash = hitVignetteT > 0 ? (hitVignetteT / 0.20) : 0;
      const vig = Math.min(0.75, lowTime * 0.55 + hitFlash * 0.45);

      if (vig > 0) {
        const g = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.15, w/2, h/2, Math.max(w,h)*0.7);
        g.addColorStop(0, "rgba(255,0,0,0)");
        g.addColorStop(1, `rgba(255,0,0,${vig})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
      }

      ctx.restore();
    }

    function render() {
      if (!areAssetsReady()) {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Loading…", canvas.width / 2, canvas.height / 2);
        return;
      }

      if (gameState === "title") { drawFullScreenImage(screenImages.title); return; }
      if (gameState === "prescreen") { drawFullScreenImage(screenImages.prescreen); return; }

      renderGame();

      if (gameState === "levelComplete") drawFullScreenImage(screenImages.complete);
      else if (gameState === "continuePrompt") drawFullScreenImage(screenImages.continue);
      else if (gameState === "gameOver") drawFullScreenImage(screenImages.gameover);
    }

    /**********************
     * MAIN LOOP
     **********************/
    let lastTime = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      try { update(dt); render(); } catch (err) { console.error(err); }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
