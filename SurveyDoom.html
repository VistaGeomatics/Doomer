<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Warehouse Run – Stolen Property Hunt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: #000;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      touch-action: none;
    }

    #game-container { margin-top: 10px; }

    canvas {
      border: 2px solid #444;
      background: #000;
      display: block;
      max-width: 100%;
      touch-action: none;
    }

    #title {
      margin-top: 8px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 14px;
      color: #888;
    }

    #hud {
      text-align: center;
      margin-top: 8px;
      font-size: 14px;
      color: #bbb;
      padding-bottom: 120px; /* room for mobile controls */
    }

    #controls { font-size: 12px; color: #777; }
    #objective { font-size: 13px; color: #aaa; margin-top: 4px; }

    /* ---------------- MOBILE CONTROLS ---------------- */
    #touch-controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 120px;
      display: none; /* enabled via JS if touch device */
      align-items: center;
      justify-content: space-between;
      padding: 14px;
      z-index: 50;
      pointer-events: none;
      background: linear-gradient(to top, rgba(0,0,0,0.55), rgba(0,0,0,0));
    }

    .pad {
      display: grid;
      grid-template-columns: 56px 56px 56px;
      grid-template-rows: 56px 56px;
      gap: 10px;
      pointer-events: auto;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    /* slightly transparent */
    .btn {
      width: 56px;
      height: 56px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,0.15);
      background: rgba(30,30,35,0.65);
      color: rgba(255,255,255,0.85);
      font-weight: 800;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 16px rgba(0,0,0,0.45);
      touch-action: none;
    }

    .btn:active,
    .btn.active {
      transform: translateY(1px);
      background: rgba(60,60,70,0.80);
      border-color: rgba(255,255,255,0.28);
    }

    .punch-wrap {
      pointer-events: auto;
      user-select: none;
      -webkit-user-select: none;
    }

    .punch {
      width: 104px;
      height: 104px;
      border-radius: 26px;
      border: 2px solid rgba(255,255,255,0.18);
      background: rgba(120,25,25,0.65);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      letter-spacing: 0.04em;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 10px 20px rgba(0,0,0,0.55);
      touch-action: none;
    }

    .punch:active {
      transform: translateY(1px);
      background: rgba(170,30,30,0.80);
    }
  </style>
</head>

<body>
  <div id="title">WAREHOUSE RUN – STOLEN GPS</div>

  <div id="game-container">
    <canvas id="game"></canvas>
  </div>

  <div id="hud">
    <div id="controls">
      W / S – Move &nbsp; | &nbsp; A / D or ← / → – Turn &nbsp; | &nbsp; Space – Punch &nbsp; | &nbsp; Q – Floor Quality
    </div>
    <div id="objective">
      Objective: Retrieve all 5 GPS components before time runs out.
    </div>
    <div id="status"></div>
  </div>

  <!-- Touch controls -->
  <div id="touch-controls" aria-label="Mobile controls">
    <div class="pad">
      <div class="btn" id="btn-left"  title="Turn left">⟵</div>
      <div class="btn" id="btn-up"    title="Forward">▲</div>
      <div class="btn" id="btn-right" title="Turn right">⟶</div>
      <div class="btn" id="btn-down"  title="Back">▼</div>
      <div style="width:56px;height:56px;"></div>
      <div style="width:56px;height:56px;"></div>
    </div>

    <div class="punch-wrap">
      <div class="punch" id="btn-punch" title="Punch">PUNCH</div>
    </div>
  </div>

  <!-- background music -->
  <audio id="bgm" src="the-metal-loop-full.wav" loop></audio>

  <script>
    /**********************
     * BASIC SETUP
     **********************/
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const bgm = document.getElementById("bgm");

    canvas.width = 960;
    canvas.height = 540;

    function loadImage(path) {
      const img = new Image();
      img.src = path;
      return img;
    }

    function isImgReady(img) {
      return img && img.complete && img.naturalWidth > 0;
    }

    function drawFullScreenImage(img) {
      const w = canvas.width, h = canvas.height;
      if (!img || !img.complete || img.width === 0) {
        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h);
        return;
      }
      ctx.drawImage(img, 0, 0, w, h);
    }

    /**********************
     * GAME STATE / SCREENS
     **********************/
    let gameState = "title"; // title, prescreen, running, continuePrompt, levelCompleteDelay, levelComplete, gameOver
    let continueUsed = false;

    const LEVEL_TIME = 120; // 2:00
    let remainingTime = LEVEL_TIME;

    // 2s win delay before cutscene
    let levelCompleteDelay = 0;

    const screenImages = {
      title: loadImage("Level3.png"),
      prescreen: loadImage("Prescreen.png"),
      complete: loadImage("level complete.png"),
      gameover: loadImage("Fail.png"),
      continue: loadImage("Continue.png")
    };

    /**********************
     * MUSIC / SFX
     **********************/
    let bgmStarted = false;
    function startBgm() {
      if (bgmStarted || !bgm) return;
      bgm.volume = 0.3;
      bgm.play().catch(() => {});
      bgmStarted = true;
    }

    const punchSound = new Audio("Punch.wav");
    punchSound.volume = 1.0;

    /**********************
     * SCREEN FEEDBACK
     **********************/
    let hitMarkerT = 0;
    let shakeT = 0;
    let shakeMag = 0;
    let hitVignetteT = 0;

    /**********************
     * MOVEMENT SMOOTHING
     **********************/
    let moveVel = 0;
    let turnVel = 0;

    const MOVE_ACCEL = 900;
    const MOVE_FRICTION = 1200;
    const MOVE_MAX = 170;

    const TURN_ACCEL = 10.0;
    const TURN_FRICTION = 14.0;
    const TURN_MAX = 2.8;

    /**********************
     * MAP
     **********************/
    const asciiMap = [
      "################################",
      "#...............##............#",
      "#....#####......##....#####...#",
      "#..###....####....####....###.#",
      "#..######.....................#",
      "#..######....######...........#",
      "#..######....######....#####..#",
      "#..###....####....####....###.#",
      "#.....####.....####.....####..#",
      "#..###....####....####....###.#",
      "#..###........P.........###...#",
      "#..###....####....####....###.#",
      "#.....####.....####.....####..#",
      "#..###....####....####....###.#",
      "#..######.....................#",
      "#..######....######...........#",
      "#..######....######....#####..#",
      "#..###....####....####....###.#",
      "#...............##............#",
      "#...............##............#",
      "################################"
    ];

    const MAP_HEIGHT = asciiMap.length;
    const MAP_WIDTH  = asciiMap[0].length;

    const map = asciiMap.map(row =>
      row.split("").map(ch => (ch === "." || ch === "P") ? 0 : 1)
    );

    const TILE_SIZE = 64;

    function tileAt(tx, ty) {
      if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) return 1;
      return map[ty][tx];
    }

    function isSolid(px, py) {
      const tx = Math.floor(px / TILE_SIZE);
      const ty = Math.floor(py / TILE_SIZE);
      return tileAt(tx, ty) !== 0;
    }

    /**********************
     * PLAYER
     **********************/
    let spawnX = 1.5, spawnY = 1.5;
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (asciiMap[y][x] === "P") { spawnX = x + 0.5; spawnY = y + 0.5; }
      }
    }

    const player = { x: spawnX * TILE_SIZE, y: spawnY * TILE_SIZE, angle: 0 };

    const FOV = Math.PI / 3;
    const NUM_RAYS = canvas.width;
    const MAX_DEPTH = 18 * TILE_SIZE;
    const depthBuffer = new Array(NUM_RAYS);

    /**********************
     * INPUT (keyboard + touch)
     **********************/
    const keys = {};
    const vkeys = { left:false, right:false, up:false, down:false };

    // Touch device detection
    const touchControlsEl = document.getElementById("touch-controls");
    const isTouch = window.matchMedia("(pointer:coarse)").matches || navigator.maxTouchPoints > 0;
    if (isTouch) touchControlsEl.style.display = "flex";

    // Floor quality toggle (1 sharp, 2 default, 3 faster)
    let FLOOR_RES = 2;

    window.addEventListener("keydown", (e) => {
      startBgm();

      if (!keys[e.code]) {
        if (e.code === "Space") handlePrimaryAction();
      }

      if (e.code === "KeyQ") {
        FLOOR_RES = (FLOOR_RES === 1) ? 2 : (FLOOR_RES === 2) ? 3 : 1;
        rebuildFloorBuffer();
      }

      keys[e.code] = true;
    });

    window.addEventListener("keyup", (e) => { keys[e.code] = false; });

    function handlePrimaryAction() {
      if (gameState === "running" && !punchState.active) { startPunch(); return; }
      if (gameState === "title") { gameState = "prescreen"; return; }
      if (gameState === "prescreen") { startLevel(); return; }
      if (gameState === "continuePrompt") {
        if (!continueUsed) { continueUsed = true; startLevel(); }
        return;
      }
      if (gameState === "levelComplete" || gameState === "gameOver") resetGameCompletely();
    }

    // Tap canvas: advance screens / punch
    canvas.addEventListener("pointerdown", (e) => {
      startBgm();
      e.preventDefault();
      handlePrimaryAction();
    }, { passive:false });

    // Virtual buttons
    function bindHoldButton(el, onDown, onUp) {
      const pointers = new Set();

      const down = (ev) => {
        startBgm();
        ev.preventDefault();
        pointers.add(ev.pointerId ?? "mouse");
        el.classList.add("active");
        onDown();
      };

      const up = (ev) => {
        ev.preventDefault();
        pointers.delete(ev.pointerId ?? "mouse");
        if (pointers.size === 0) el.classList.remove("active");
        onUp();
      };

      el.addEventListener("pointerdown", down, { passive:false });
      el.addEventListener("pointerup", up, { passive:false });
      el.addEventListener("pointercancel", up, { passive:false });
      el.addEventListener("pointerleave", up, { passive:false });
    }

    bindHoldButton(document.getElementById("btn-left"),  () => vkeys.left  = true, () => vkeys.left  = false);
    bindHoldButton(document.getElementById("btn-right"), () => vkeys.right = true, () => vkeys.right = false);
    bindHoldButton(document.getElementById("btn-up"),    () => vkeys.up    = true, () => vkeys.up    = false);
    bindHoldButton(document.getElementById("btn-down"),  () => vkeys.down  = true, () => vkeys.down  = false);

    // Punch button: press once
    (function bindPunchOnce(){
      const el = document.getElementById("btn-punch");
      let pressed = false;

      el.addEventListener("pointerdown", (ev) => {
        startBgm();
        ev.preventDefault();
        if (pressed) return;
        pressed = true;
        el.classList.add("active");

        if (gameState === "running") {
          if (!punchState.active) startPunch();
        } else {
          handlePrimaryAction();
        }
      }, { passive:false });

      const release = (ev) => {
        ev.preventDefault();
        pressed = false;
        el.classList.remove("active");
      };

      el.addEventListener("pointerup", release, { passive:false });
      el.addEventListener("pointercancel", release, { passive:false });
      el.addEventListener("pointerleave", release, { passive:false });
    })();

    // Mobile look: drag-to-turn with deadzone
    let lookPointerId = null;
    let lookLastX = 0;
    const LOOK_SENS = 0.006;
    const LOOK_DEADZONE = 6;

    canvas.addEventListener("pointerdown", (e) => {
      if (!isTouch) return;
      lookPointerId = e.pointerId;
      lookLastX = e.clientX;
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!isTouch) return;
      if (lookPointerId !== e.pointerId) return;

      const dx = e.clientX - lookLastX;
      lookLastX = e.clientX;
      if (Math.abs(dx) < LOOK_DEADZONE) return;

      turnVel += dx * LOOK_SENS;
      turnVel = Math.max(-TURN_MAX, Math.min(TURN_MAX, turnVel));
    });

    canvas.addEventListener("pointerup", (e) => { if (lookPointerId === e.pointerId) lookPointerId = null; });
    canvas.addEventListener("pointercancel", (e) => { if (lookPointerId === e.pointerId) lookPointerId = null; });

    /**********************
     * ENEMIES / ITEMS
     **********************/
    const enemies = [
      { x: (6.5)  * TILE_SIZE, y: (3.5)  * TILE_SIZE },
      { x: (22.5) * TILE_SIZE, y: (3.5)  * TILE_SIZE },
      { x: (6.5)  * TILE_SIZE, y: (13.5) * TILE_SIZE },
      { x: (22.5) * TILE_SIZE, y: (13.5) * TILE_SIZE },
      { x: (15.5) * TILE_SIZE, y: (9.5)  * TILE_SIZE }
    ].map(e => ({
      ...e,
      alive: true,
      health: 3,
      state: "alive",
      deathTimer: 0,
      finalHitTimer: 0,
      dir: Math.random() * Math.PI * 2,
      turnTimer: 1 + Math.random() * 2,
      animTime: 0,
      animFrame: 0,
      moving: false,
      movingAway: false,
      prevDistToPlayer: 0,
      hitTimer: 0
    }));

    const ENEMY_SPEED = 55;
    const ENEMY_AVOID_RADIUS = 4 * TILE_SIZE;
    const ENEMY_ANIM_FRAME_TIME = 0.16;

    let itemsCollected = 0;
    const totalItems = enemies.length;

    function updateStatusText() {
      statusEl.textContent = (itemsCollected >= totalItems)
        ? "All GPS components recovered!"
        : `GPS components recovered: ${itemsCollected} / ${totalItems}`;
    }
    updateStatusText();

    function resetEnemies() {
      const positions = [
        { x: (6.5)  * TILE_SIZE, y: (3.5)  * TILE_SIZE },
        { x: (22.5) * TILE_SIZE, y: (3.5)  * TILE_SIZE },
        { x: (6.5)  * TILE_SIZE, y: (13.5) * TILE_SIZE },
        { x: (22.5) * TILE_SIZE, y: (13.5) * TILE_SIZE },
        { x: (15.5) * TILE_SIZE, y: (9.5)  * TILE_SIZE }
      ];
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i], p = positions[i];
        e.x = p.x; e.y = p.y;
        e.alive = true; e.health = 3; e.state = "alive";
        e.deathTimer = 0; e.finalHitTimer = 0;
        e.dir = Math.random() * Math.PI * 2;
        e.turnTimer = 1 + Math.random() * 2;
        e.animTime = 0; e.animFrame = 0;
        e.moving = false; e.movingAway = false;
        e.prevDistToPlayer = 0; e.hitTimer = 0;
      }
    }

    function startLevel() {
      gameState = "running";
      remainingTime = LEVEL_TIME;
      levelCompleteDelay = 0;

      player.x = spawnX * TILE_SIZE;
      player.y = spawnY * TILE_SIZE;
      player.angle = 0;

      moveVel = 0;
      turnVel = 0;

      resetEnemies();
      itemsCollected = 0;
      updateStatusText();
    }

    function resetGameCompletely() {
      continueUsed = false;
      itemsCollected = 0;
      remainingTime = LEVEL_TIME;
      levelCompleteDelay = 0;

      resetEnemies();
      player.x = spawnX * TILE_SIZE;
      player.y = spawnY * TILE_SIZE;
      player.angle = 0;

      moveVel = 0;
      turnVel = 0;

      gameState = "title";
      updateStatusText();
    }

    function updateEnemies(dt) {
      for (const e of enemies) {
        if (e.state === "finalHit") {
          e.finalHitTimer -= dt;
          if (e.finalHitTimer <= 0) { e.state = "dying"; e.deathTimer = 0.6; }
          continue;
        }
        if (e.state === "dying") {
          e.deathTimer -= dt;
          if (e.deathTimer <= 0) e.state = "dead";
          continue;
        }
        if (e.state === "dead") continue;

        if (e.hitTimer > 0) {
          e.hitTimer -= dt;
          if (e.hitTimer < 0) e.hitTimer = 0;
        }

        const dx0 = player.x - e.x;
        const dy0 = player.y - e.y;
        const d0 = Math.hypot(dx0, dy0);
        e.prevDistToPlayer = d0;

        if (d0 < ENEMY_AVOID_RADIUS) {
          const a = Math.atan2(dy0, dx0);
          e.dir = a + Math.PI + (Math.random() - 0.5) * 0.4;
          e.turnTimer = 0.3;
        } else {
          e.turnTimer -= dt;
          if (e.turnTimer <= 0) {
            e.dir = Math.random() * Math.PI * 2;
            e.turnTimer = 1 + Math.random() * 2;
          }
        }

        const dx = Math.cos(e.dir) * ENEMY_SPEED * dt;
        const dy = Math.sin(e.dir) * ENEMY_SPEED * dt;

        const oldX = e.x, oldY = e.y;

        const nx = e.x + dx;
        const ny = e.y + dy;

        if (!isSolid(nx, e.y)) e.x = nx; else e.dir = Math.random() * Math.PI * 2;
        if (!isSolid(e.x, ny)) e.y = ny; else e.dir = Math.random() * Math.PI * 2;

        e.moving = Math.hypot(e.x - oldX, e.y - oldY) > 0.5;

        const dx1 = player.x - e.x;
        const dy1 = player.y - e.y;
        const d1 = Math.hypot(dx1, dy1);
        e.movingAway = d1 > e.prevDistToPlayer + 1;

        if (e.moving) {
          e.animTime += dt;
          if (e.animTime >= ENEMY_ANIM_FRAME_TIME) {
            e.animTime = 0;
            e.animFrame = 1 - e.animFrame;
          }
        } else {
          e.animTime = 0;
          e.animFrame = 0;
        }
      }
    }

    /**********************
     * PUNCH
     **********************/
    const punchState = { active:false, time:0, duration:0.25, justHit:false };
    const PUNCH_RANGE = 1.5 * TILE_SIZE;
    const PUNCH_ARC   = Math.PI / 4;

    function normalizeAngle(a) {
      while (a < -Math.PI) a += 2*Math.PI;
      while (a >  Math.PI) a -= 2*Math.PI;
      return a;
    }

    function startPunch() {
      punchState.active = true;
      punchState.time = 0;
      punchState.justHit = false;

      if (navigator.vibrate) navigator.vibrate(20);

      try { punchSound.currentTime = 0; punchSound.play().catch(() => {}); } catch {}

      performPunch();
    }

    function performPunch() {
      let hitAny = false;

      for (const enemy of enemies) {
        if (enemy.state !== "alive") continue;

        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist > PUNCH_RANGE) continue;

        const angleTo = Math.atan2(dy, dx);
        const diff = normalizeAngle(angleTo - player.angle);
        if (Math.abs(diff) > PUNCH_ARC) continue;

        enemy.health -= 1;

        if (enemy.health > 0) {
          enemy.hitTimer = 0.2;
        } else {
          enemy.alive = false;
          enemy.state = "finalHit";
          enemy.finalHitTimer = 0.2;
          enemy.hitTimer = 0;
          itemsCollected++;
        }

        hitAny = true;
      }

      punchState.justHit = hitAny;

      if (hitAny) {
        hitMarkerT = 0.15;
        shakeT = 0.12;
        shakeMag = 6;
        hitVignetteT = 0.20;
        updateStatusText();
      }
    }

    const punchImages = [];
    let punchImagesLoaded = 0;
    ["punch1.png", "punch2.png", "punch3.png"].forEach((file, idx) => {
      const img = new Image();
      img.src = file;
      img.onload = () => { punchImagesLoaded++; };
      punchImages[idx] = img;
    });

    function getPunchFrame() {
      if (!punchState.active || punchImagesLoaded === 0) return null;
      const t = punchState.time / punchState.duration;
      let frameIndex = 0;
      if (t > 0.4 && t <= 0.8) frameIndex = 1;
      else if (t > 0.8) frameIndex = 2;
      return punchImages[frameIndex];
    }

    /**********************
     * TEXTURES
     **********************/
    const wallTextureFiles = ["Wall1.png", "Wall2.png", "wall3.png"];
    const wallTextures = wallTextureFiles.map(f => {
      const img = new Image();
      img.src = f;
      return img;
    });

    // Floor texture
    const floorImg = new Image();
    floorImg.src = "floor 69.jpg";

    const floorTex = { ready:false, w:0, h:0, data:null };

    floorImg.onload = () => {
      const c = document.createElement("canvas");
      c.width = floorImg.width;
      c.height = floorImg.height;
      const cctx = c.getContext("2d", { willReadFrequently: true });
      cctx.drawImage(floorImg, 0, 0);
      const imgd = cctx.getImageData(0, 0, c.width, c.height);
      floorTex.ready = true;
      floorTex.w = c.width;
      floorTex.h = c.height;
      floorTex.data = imgd.data;
    };

    // Floor buffer
    const floorBuf = document.createElement("canvas");
    const floorCtx = floorBuf.getContext("2d", { willReadFrequently: true });
    let floorFrame = null;

    function rebuildFloorBuffer() {
      floorBuf.width = Math.ceil(canvas.width / FLOOR_RES);
      floorBuf.height = Math.ceil((canvas.height / 2) / FLOOR_RES);
      floorFrame = floorCtx.createImageData(floorBuf.width, floorBuf.height);
    }
    rebuildFloorBuffer();

    const FLOOR_TEX_WORLD_SCALE = 0.22;

    function sampleFloorRGB(wx, wy) {
      const tw = floorTex.w, th = floorTex.h;
      let tx = Math.floor(wx * FLOOR_TEX_WORLD_SCALE) % tw;
      let ty = Math.floor(wy * FLOOR_TEX_WORLD_SCALE) % th;
      if (tx < 0) tx += tw;
      if (ty < 0) ty += th;
      const idx = (ty * tw + tx) * 4;
      return [ floorTex.data[idx], floorTex.data[idx+1], floorTex.data[idx+2] ];
    }

    function renderFloorPerspective(halfH) {
      const w = canvas.width, h = canvas.height;

      if (!floorTex.ready || !floorFrame) {
        ctx.fillStyle = "#303033";
        ctx.fillRect(0, halfH, w, halfH);
        return;
      }

      const bw = floorBuf.width;
      const bh = floorBuf.height;
      const data = floorFrame.data;

      const leftA  = player.angle - FOV / 2;
      const rightA = player.angle + FOV / 2;

      const leftDX  = Math.cos(leftA);
      const leftDY  = Math.sin(leftA);
      const rightDX = Math.cos(rightA);
      const rightDY = Math.sin(rightA);

      const cameraHeight = 0.55 * TILE_SIZE;
      const projPlane = halfH;

      for (let yb = 0; yb < bh; yb++) {
        const screenY = halfH + (yb * FLOOR_RES);
        const p = (screenY - halfH);
        const rowDist = (cameraHeight * projPlane) / Math.max(1, p);

        const stepX = rowDist * (rightDX - leftDX) / bw;
        const stepY = rowDist * (rightDY - leftDY) / bw;

        let fx = player.x + rowDist * leftDX;
        let fy = player.y + rowDist * leftDY;

        const shade = Math.max(0.15, 1 - (rowDist / (MAX_DEPTH * 0.9)));

        for (let xb = 0; xb < bw; xb++) {
          const [r0,g0,b0] = sampleFloorRGB(fx, fy);
          const r = Math.floor(r0 * shade);
          const g = Math.floor(g0 * shade);
          const b = Math.floor(b0 * shade);

          const o = (yb * bw + xb) * 4;
          data[o] = r; data[o+1] = g; data[o+2] = b; data[o+3] = 255;

          fx += stepX;
          fy += stepY;
        }
      }

      floorCtx.putImageData(floorFrame, 0, 0);

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(floorBuf, 0, 0, bw, bh, 0, halfH, w, h - halfH);
      ctx.restore();
    }

    /**********************
     * SPRITES
     **********************/
    const burglarSprites = { standing:null, walk1:null, walk2:null, away:null, hit:null, falling:null, dead:null };

    function loadBurglarSprite(name, file) {
      const img = new Image();
      img.src = file;
      img.onload = () => { burglarSprites[name] = img; };
      return img;
    }

    loadBurglarSprite("standing","BGStanding.png");
    loadBurglarSprite("walk1","BGWalking1.png");
    loadBurglarSprite("walk2","BGwalking2.png");
    loadBurglarSprite("away","BGWalkingaway.png");
    loadBurglarSprite("hit","BGpunch.png");
    loadBurglarSprite("falling","Falling1.png");
    loadBurglarSprite("dead","Dead.png");

    /**********************
     * HUD ASSETS
     **********************/
    const hud = { bar:null, items:[], happyFace:null, angryFace:null };
    hud.bar = loadImage("Bar.png");
    hud.items[0] = loadImage("BRX72.png");
    hud.items[1] = loadImage("Data collector copy.png");
    hud.items[2] = loadImage("Tribrachs.png");
    hud.items[3] = loadImage("battery copy.png");
    hud.items[4] = loadImage("BRX71.png");
    hud.happyFace = loadImage("Happy Face.png");
    hud.angryFace = loadImage("Angry face.png");

    function areAssetsReady() {
      for (const k in screenImages) if (!isImgReady(screenImages[k])) return false;
      if (!isImgReady(hud.bar)) return false;
      for (const it of hud.items) if (!isImgReady(it)) return false;
      if (!isImgReady(hud.happyFace) || !isImgReady(hud.angryFace)) return false;
      if (!isImgReady(burglarSprites.standing)) return false;
      if (!floorTex.ready) return false;
      return true;
    }

    /**********************
     * RAYCAST
     **********************/
    function castRay(rayAngle) {
      rayAngle = (rayAngle + Math.PI*2) % (Math.PI*2);
      const sin = Math.sin(rayAngle), cos = Math.cos(rayAngle);

      const stepSize = 4;
      let rayX = player.x, rayY = player.y, distance = 0;
      let hitTile = 0, hitMapX = 0, hitMapY = 0;

      while (distance < MAX_DEPTH) {
        rayX += cos * stepSize;
        rayY += sin * stepSize;
        distance += stepSize;

        const tx = Math.floor(rayX / TILE_SIZE);
        const ty = Math.floor(rayY / TILE_SIZE);

        if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) {
          hitTile = 1; hitMapX = tx; hitMapY = ty; break;
        }

        const t = tileAt(tx, ty);
        if (t !== 0) { hitTile = t; hitMapX = tx; hitMapY = ty; break; }
      }

      return { distance, tile: hitTile, hitMapX, hitMapY, worldX: rayX, worldY: rayY };
    }

    /**********************
     * ENEMY RENDER
     **********************/
    function getVisibleEnemies() {
      const result = [];
      for (const enemy of enemies) {
        const dx = enemy.x - player.x, dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        const angleTo = Math.atan2(dy, dx);
        const diff = normalizeAngle(angleTo - player.angle);
        if (Math.abs(diff) > FOV/2) continue;
        result.push({ enemy, dist, diff });
      }
      result.sort((a,b) => b.dist - a.dist);
      return result;
    }

    function chooseBurglarFrame(enemy) {
      if (enemy.state === "finalHit" && burglarSprites.hit) return burglarSprites.hit;
      if (enemy.state === "dying" && burglarSprites.falling) return burglarSprites.falling;
      if (enemy.state === "dead" && burglarSprites.dead) return burglarSprites.dead;
      if (enemy.hitTimer > 0 && burglarSprites.hit) return burglarSprites.hit;
      if (!burglarSprites.standing) return null;

      if (!enemy.moving) return burglarSprites.standing;
      if (enemy.movingAway && burglarSprites.away) return burglarSprites.away;
      if (enemy.animFrame === 0 && burglarSprites.walk1) return burglarSprites.walk1;
      if (enemy.animFrame === 1 && burglarSprites.walk2) return burglarSprites.walk2;

      return burglarSprites.standing;
    }

    function renderEnemies(halfH) {
      const visible = getVisibleEnemies();
      const w = canvas.width;

      for (const obj of visible) {
        const { enemy, dist, diff } = obj;
        const screenX = (0.5 + (diff / FOV)) * w;
        const sprite = chooseBurglarFrame(enemy);
        if (!sprite) continue;

        const spriteHeight = (TILE_SIZE / dist) * 360;
        const spriteWidth  = spriteHeight * (sprite.width / sprite.height);
        const spriteY = halfH - spriteHeight/2 + spriteHeight*0.15;
        const spriteX = screenX - spriteWidth/2;

        // occlusion test
        const leftCol  = Math.max(0, Math.floor(spriteX));
        const rightCol = Math.min(NUM_RAYS - 1, Math.floor(spriteX + spriteWidth));
        let blocked = true;
        const correctedEnemyDist = dist * Math.cos(diff);
        for (let col = leftCol; col <= rightCol; col++) {
          if (depthBuffer[col] > correctedEnemyDist) { blocked = false; break; }
        }
        if (blocked) continue;

        ctx.drawImage(sprite, spriteX, spriteY, spriteWidth, spriteHeight);
      }
    }

    /**********************
     * HUD DRAW
     **********************/
    function renderHUD() {
      const w = canvas.width, h = canvas.height;
      const hudHeight = 90;
      const hudTop = h - hudHeight;

      if (hud.bar && hud.bar.complete && hud.bar.width > 0) {
        ctx.drawImage(hud.bar, 0, hudTop, w, hudHeight);
      } else {
        ctx.fillStyle = "#222";
        ctx.fillRect(0, hudTop, w, hudHeight);
      }

      const columns = 7;
      const colW = w / columns;
      const centerY = hudTop + hudHeight / 2;

      // tribrach + battery smaller
      const ITEM_DRAW = [
        { scale: 0.50, slot: 0 }, // BRX72.png
        { scale: 0.50, slot: 1 }, // Data collector copy.png
        { scale: 0.30, slot: 2 }, // Tribrachs.png
        { scale: 0.30, slot: 4 }, // battery copy.png
        { scale: 0.45, slot: 5 }  // BRX71.png
      ];

      for (let i = 0; i < 5; i++) {
        if (itemsCollected > i && hud.items[i] && hud.items[i].complete) {
          const img = hud.items[i];
          const cfg = ITEM_DRAW[i];

          const maxW = colW * 0.72;
          const maxH = hudHeight * 0.72;

          let iw = img.width * cfg.scale;
          let ih = img.height * cfg.scale;

          const clamp = Math.min(1, maxW / iw, maxH / ih);
          iw *= clamp;
          ih *= clamp;

          const cx = colW * (cfg.slot + 0.5);
          ctx.drawImage(img, cx - iw/2, centerY - ih/2, iw, ih);
        }
      }

      // face
      let faceImg = null;
      if (punchState.active && punchState.time < punchState.duration * 0.5 && hud.angryFace && hud.angryFace.complete) {
        faceImg = hud.angryFace;
      } else if (hud.happyFace && hud.happyFace.complete) {
        faceImg = hud.happyFace;
      }

      if (faceImg) {
        const scale = 0.07;
        const iw = faceImg.width * scale, ih = faceImg.height * scale;
        const cx = colW * (3 + 0.5);
        ctx.drawImage(faceImg, cx - iw/2, centerY - ih/2, iw, ih);
      }

      // timer
      const timerX = colW * (6 + 0.5);
      const totalSeconds = Math.max(0, Math.floor(remainingTime));
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const timeStr = `${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;

      ctx.font = "28px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#ff3333";
      ctx.fillText(timeStr, timerX, centerY + 4);
    }

    /**********************
     * UPDATE
     **********************/
    function update(dt) {
      if (gameState === "levelCompleteDelay") {
        levelCompleteDelay -= dt;
        if (levelCompleteDelay <= 0) gameState = "levelComplete";
        return;
      }

      if (gameState !== "running") {
        if (punchState.active) {
          punchState.time += dt;
          if (punchState.time >= punchState.duration) {
            punchState.active = false;
            punchState.time = 0;
            punchState.justHit = false;
          }
        }
        return;
      }

      // tick feedback timers
      hitMarkerT = Math.max(0, hitMarkerT - dt);
      shakeT = Math.max(0, shakeT - dt);
      hitVignetteT = Math.max(0, hitVignetteT - dt);

      // Smooth turn
      const turnLeft  = keys["ArrowLeft"] || keys["KeyA"] || vkeys.left;
      const turnRight = keys["ArrowRight"]|| keys["KeyD"] || vkeys.right;

      let turnInput = 0;
      if (turnLeft) turnInput -= 1;
      if (turnRight) turnInput += 1;

      turnVel += turnInput * TURN_ACCEL * dt;

      if (turnInput === 0) {
        const drag = TURN_FRICTION * dt;
        if (turnVel > 0) turnVel = Math.max(0, turnVel - drag);
        else turnVel = Math.min(0, turnVel + drag);
      }

      turnVel = Math.max(-TURN_MAX, Math.min(TURN_MAX, turnVel));
      player.angle += turnVel * dt;

      // Smooth move
      const forward = keys["ArrowUp"] || keys["KeyW"] || vkeys.up;
      const back    = keys["ArrowDown"] || keys["KeyS"] || vkeys.down;

      let moveInput = 0;
      if (forward) moveInput += 1;
      if (back)    moveInput -= 1;

      moveVel += moveInput * MOVE_ACCEL * dt;

      if (moveInput === 0) {
        const drag = MOVE_FRICTION * dt;
        if (moveVel > 0) moveVel = Math.max(0, moveVel - drag);
        else moveVel = Math.min(0, moveVel + drag);
      }

      moveVel = Math.max(-MOVE_MAX, Math.min(MOVE_MAX, moveVel));

      const dx = Math.cos(player.angle) * moveVel * dt;
      const dy = Math.sin(player.angle) * moveVel * dt;

      const newX = player.x + dx;
      const newY = player.y + dy;

      if (!isSolid(newX, player.y)) player.x = newX;
      if (!isSolid(player.x, newY)) player.y = newY;

      // punch animation timing
      if (punchState.active) {
        punchState.time += dt;
        if (punchState.time >= punchState.duration) {
          punchState.active = false;
          punchState.time = 0;
          punchState.justHit = false;
        }
      }

      updateEnemies(dt);

      // timer
      remainingTime -= dt;
      if (remainingTime <= 0) {
        remainingTime = 0;
        if (itemsCollected >= totalItems) {
          gameState = "levelCompleteDelay";
          levelCompleteDelay = 2.0;
        } else if (!continueUsed) {
          gameState = "continuePrompt";
        } else {
          gameState = "gameOver";
        }
      }

      // win
      if (itemsCollected >= totalItems && gameState === "running") {
        gameState = "levelCompleteDelay";
        levelCompleteDelay = 2.0;
      }
    }

    /**********************
     * RENDER
     **********************/
    function renderGame() {
      const w = canvas.width, h = canvas.height;
      const halfH = h / 2;

      ctx.clearRect(0, 0, w, h);

      // shake
      ctx.save();
      if (shakeT > 0) {
        const s = (shakeT / 0.12);
        const mag = shakeMag * s;
        ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
      }

      // ceiling
      const ceilingGrad = ctx.createLinearGradient(0, 0, 0, halfH);
      ceilingGrad.addColorStop(0, "#101015");
      ceilingGrad.addColorStop(1, "#181820");
      ctx.fillStyle = ceilingGrad;
      ctx.fillRect(0, 0, w, halfH);

      // floor
      renderFloorPerspective(halfH);

      // walls
      for (let i = 0; i < NUM_RAYS; i++) {
        const rayScreenPos = i / NUM_RAYS - 0.5;
        const rayAngle = player.angle + rayScreenPos * FOV;

        const { distance, tile, hitMapX, hitMapY, worldX, worldY } = castRay(rayAngle);
        if (tile === 0) { depthBuffer[i] = MAX_DEPTH; continue; }

        const corrected = distance * Math.cos(rayAngle - player.angle);
        depthBuffer[i] = corrected;

        const wallHeight = (TILE_SIZE / corrected) * 220;
        const colHeight = wallHeight;
        const colY = halfH - colHeight / 2;

        const texIndex = ((hitMapX + hitMapY) % wallTextures.length + wallTextures.length) % wallTextures.length;
        const tex = wallTextures[texIndex];

        if (tex && tex.complete && tex.width > 0) {
          const texW = tex.width, texH = tex.height;

          const hitXmod = ((worldX % TILE_SIZE) + TILE_SIZE) % TILE_SIZE;
          const hitYmod = ((worldY % TILE_SIZE) + TILE_SIZE) % TILE_SIZE;

          let u;
          if (hitXmod < 1 || hitXmod > TILE_SIZE - 1) u = hitYmod / TILE_SIZE;
          else u = hitXmod / TILE_SIZE;

          const texX = Math.floor(u * texW);
          ctx.drawImage(tex, texX, 0, 1, texH, i, colY, 1, colHeight);
        } else {
          ctx.fillStyle = "#7a3b2e";
          ctx.fillRect(i, colY, 1, colHeight);
        }

        const shadow = Math.min(0.8, corrected / (MAX_DEPTH * 0.9));
        ctx.save();
        ctx.globalAlpha = shadow;
        ctx.fillStyle = "#000";
        ctx.fillRect(i, colY, 1, colHeight);
        ctx.restore();
      }

      // enemies
      renderEnemies(halfH);

      // fist (before HUD)
      const frame = getPunchFrame();
      if (frame) {
        const hudHeight = 90;
        const scale = 2.2;
        const imgW = frame.width * scale;
        const imgH = frame.height * scale;
        const x = w / 2 - imgW / 2 + 60;
        const y = h - hudHeight - imgH + 35;
        ctx.drawImage(frame, x, y, imgW, imgH);
      }

      // minimap
      const miniScale = 5, offsetX = 10, offsetY = 10;
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          const t = tileAt(x, y);
          ctx.fillStyle = (t === 0) ? "#202020" : "#7a3b2e";
          ctx.fillRect(offsetX + x * miniScale, offsetY + y * miniScale, miniScale, miniScale);
        }
      }

      for (const enemy of enemies) {
        const ex = offsetX + (enemy.x / TILE_SIZE) * miniScale;
        const ey = offsetY + (enemy.y / TILE_SIZE) * miniScale;
        ctx.fillStyle = (enemy.state === "dead" || enemy.state === "dying" || enemy.state === "finalHit") ? "#aa0000" : "#ff4444";
        ctx.fillRect(ex - 2, ey - 2, 4, 4);
      }

      const px = offsetX + (player.x / TILE_SIZE) * miniScale;
      const py = offsetY + (player.y / TILE_SIZE) * miniScale;
      ctx.fillStyle = "#00ff88";
      ctx.fillRect(px - 2, py - 2, 4, 4);

      ctx.strokeStyle = "#00ff88";
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px + Math.cos(player.angle) * 10, py + Math.sin(player.angle) * 10);
      ctx.stroke();

      // HUD
      renderHUD();

      // Crosshair
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(w/2, h/2, 2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // Hit marker X
      if (hitMarkerT > 0) {
        const a = hitMarkerT / 0.15;
        const size = 10;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/2 - size, h/2 - size);
        ctx.lineTo(w/2 + size, h/2 + size);
        ctx.moveTo(w/2 + size, h/2 - size);
        ctx.lineTo(w/2 - size, h/2 + size);
        ctx.stroke();
        ctx.restore();
      }

      // Vignette (time low + hit flash)
      const lowTime = remainingTime <= 15 ? (1 - remainingTime / 15) : 0;
      const hitFlash = hitVignetteT > 0 ? (hitVignetteT / 0.20) : 0;
      const vig = Math.min(0.75, lowTime * 0.55 + hitFlash * 0.45);

      if (vig > 0) {
        const g = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.15, w/2, h/2, Math.max(w,h)*0.7);
        g.addColorStop(0, "rgba(255,0,0,0)");
        g.addColorStop(1, `rgba(255,0,0,${vig})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
      }

      ctx.restore(); // end shake
    }

    function render() {
      // Loading screen
      if (!areAssetsReady()) {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Loading…", canvas.width / 2, canvas.height / 2);
        return;
      }

      if (gameState === "title") { drawFullScreenImage(screenImages.title); return; }
      if (gameState === "prescreen") { drawFullScreenImage(screenImages.prescreen); return; }

      renderGame();

      if (gameState === "levelComplete") drawFullScreenImage(screenImages.complete);
      else if (gameState === "continuePrompt") drawFullScreenImage(screenImages.continue);
      else if (gameState === "gameOver") drawFullScreenImage(screenImages.gameover);
    }

    /**********************
     * MAIN LOOP (CRASH-PROOF)
     **********************/
    let lastTime = performance.now();

    function loop(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      try {
        update(dt);
        render();
      } catch (err) {
        console.error(err);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ff5555";
        ctx.font = "16px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Game error, check console (F12).", canvas.width/2, canvas.height/2);
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
